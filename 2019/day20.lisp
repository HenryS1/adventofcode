(load "../2018/queue.lisp")
(ql:quickload :cl-ppcre)
(ql:quickload :iterate)
(ql:quickload :anaphora)
(ql:quickload :metabang-bind)
(ql:quickload :alexandria)

(defpackage :day20
  (:use :cl :cl-ppcre :iterate :alexandria :anaphora :metabang-bind))

(in-package :day20)

(defun ints (line) 
  (mapcar #'parse-integer (all-matches-as-strings "-?\\d+" line)))

(defun read-syms (line &optional (sep " "))
  (let (*read-eval*)
    (mapcar #'read-from-string (split sep line))))

(defun read-lines ()
  (iter (for line in-file "input20" using #'read-line) 
        (collect line)))

(defun read-map ()
  (let* ((mp (make-hash-table :test 'equal))
         start
         end
         (portals (make-hash-table :test 'equal)))
    (labels ((add-labelled-coord (i j label)
               (when (string= label "AA")
                 (setf start (cons i j)))
               (when (string= label "ZZ")
                 (setf end (cons i j)))
               (setf (gethash (cons i j) mp) label)
               (push (cons i j) (gethash label portals))))
      (iter (for line in (read-lines))
        (for line-p previous line)
        (for line-pp previous line-p)
        (for i from 0)
        (iter (for c in-string line)
              (for c-p previous c)
              (for c-pp previous c-p)
              (for j index-of-vector line)
              (when (char= c #\.)
                (cond ((and c-p c-pp (upper-case-p c-p) (upper-case-p c-pp))
                       (let ((label (coerce (list c-pp c-p) 'string)))
                         (add-labelled-coord i j label)))
                      ((and line-p line-pp (upper-case-p (aref line-p j))
                            (upper-case-p (aref line-pp j)))
                       (let ((label (coerce (list (aref line-pp j) (aref line-p j)) 'string)))
                         (add-labelled-coord i j label)))
                      (t (setf (gethash (cons i j) mp) (format nil "~a ~a" i j)))))
              (when (and c-pp c-p (char= c-pp #\.) (upper-case-p c-p) (upper-case-p c))
                (let ((label (coerce (list c-p c) 'string)))
                  (add-labelled-coord i (- j 2) label)))
              (when (and line-pp line-p (char= (aref line-pp j) #\.) 
                         (upper-case-p (aref line j))
                         (upper-case-p (aref line-p j)))
                (add-labelled-coord (- i 2) j
                                    (coerce (list (aref line-p j) (aref line j)) 'string))))
        (finally (return (progn
                           (list mp portals start end))))))))

(defun neighbours (coord mp portals)
  (let (nbrs
        (i (car coord))
        (j (cdr coord)))
    (awhen (gethash (gethash coord mp) portals)
      (iter (for other in it)
            (when (not (equal other coord))
              (push other nbrs))))
    (when (gethash (cons (- i 1) j) mp)
      (push (cons (- i 1) j) nbrs))
    (when (gethash (cons (+ i 1) j) mp)
      (push (cons (+ i 1) j) nbrs))
    (when (gethash (cons i (- j 1)) mp)
      (push (cons i (- j 1)) nbrs))
    (when (gethash (cons i (+ j 1)) mp)
      (push (cons i (+ j 1)) nbrs))
    nbrs))

(defun answer-1 ()
  (iter (with (mp portals start end) = (read-map))
        (with q = (make-queue (cons start 0)))
        (with seen = (alist-hash-table (list (cons start "AA")) :test 'equal))
        (while (non-empty q))
        (for (coord . moves-to) = (poll q))
        (when (equal coord end)
          (return moves-to))
        (iter (for nbr in (neighbours coord mp portals))
              (when (not (gethash nbr seen))
                (setf (gethash nbr seen) t)
                (enqueue (cons nbr (+ moves-to 1)) q)))))

(defun recursive-neighbours (coord level mp portals)
  (let (nbrs
        (i (car coord))
        (j (cdr coord)))
    (awhen (gethash (gethash coord mp) portals)
      (iter (for nbr in it)
            (for (other direction) = nbr)
            (when (and (not (equal other coord)) (or (> level 0) (> direction 0)))
              (push (list (cons (car other) (cdr other)) (+ level direction)) nbrs))))
    (when (gethash (cons (- i 1) j) mp)
      (push (list (cons (- i 1) j) level) nbrs))
    (when (gethash (cons (+ i 1) j) mp)
      (push (list (cons (+ i 1) j) level) nbrs))
    (when (gethash (cons i (- j 1)) mp)
      (push (list (cons i (- j 1)) level) nbrs))
    (when (gethash (cons i (+ j 1)) mp)
      (push (list (cons i (+ j 1)) level) nbrs))
    nbrs))

(defun determine-direction (i j lines)
  (if (or (= i 2) (= j 2)
          (= i (- (length lines) 3))
          (= j (- (length (car lines)) 3)))
      1
      -1))

(defun read-map-with-levels ()
  (let* ((mp (make-hash-table :test 'equal))
         start
         end
         (portals (make-hash-table :test 'equal))
         (lines (read-lines)))
    (labels ((add-labelled-coord (i j label)
               (when (string= label "AA")
                 (setf start (cons i j)))
               (when (string= label "ZZ")
                 (setf end (cons i j)))
               (setf (gethash (cons i j) mp) label)
               (push (list (cons i j) (determine-direction i j lines))
                     (gethash label portals))))
      (iter (for line in lines)
            (for line-p previous line)
            (for line-pp previous line-p)
            (for i from 0)
            (iter (for c in-string line)
                  (for c-p previous c)
                  (for c-pp previous c-p)
                  (for j index-of-vector line)
                  (when (char= c #\.)
                    (cond ((and c-p c-pp (upper-case-p c-p) (upper-case-p c-pp))
                           (let ((label (coerce (list c-pp c-p) 'string)))
                             (add-labelled-coord i j label)))
                          ((and line-p line-pp (upper-case-p (aref line-p j))
                                (upper-case-p (aref line-pp j)))
                           (let ((label (coerce (list (aref line-pp j) (aref line-p j)) 'string)))
                             (add-labelled-coord i j label)))
                          (t (setf (gethash (cons i j) mp) (format nil "~a ~a" i j)))))
                  (when (and c-pp c-p (char= c-pp #\.) (upper-case-p c-p) (upper-case-p c))
                    (let ((label (coerce (list c-p c) 'string)))
                      (add-labelled-coord i (- j 2) label)))
                  (when (and line-pp line-p (char= (aref line-pp j) #\.) 
                             (upper-case-p (aref line j))
                             (upper-case-p (aref line-p j)))
                    (add-labelled-coord (- i 2) j
                                        (coerce (list (aref line-p j) (aref line j)) 'string))))
            (finally (return (list mp portals start end)))))))

(defun answer-2 ()
  (iter (with (mp portals start end) = (read-map-with-levels))
        (with q = (make-queue (cons (list start 0) 0)))
        (with seen = (alist-hash-table (list (cons (list start 0) t)) :test 'equal))
        (while (non-empty q))
        (for ((coord level) . moves-to) = (poll q))
        (when (and (equal coord end) (= level 0))
          (return moves-to))
        (iter (for nbr in (recursive-neighbours coord level mp portals))
              (when (not (gethash nbr seen))
                (setf (gethash nbr seen) t)
                (enqueue (cons nbr (+ moves-to 1)) q)))))
