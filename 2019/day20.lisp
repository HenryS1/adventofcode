(load "../2018/queue.lisp")
(ql:quickload :cl-ppcre)
(ql:quickload :iterate)
(ql:quickload :anaphora)
(ql:quickload :metabang-bind)
(ql:quickload :alexandria)

(defpackage :day20
  (:use :cl :cl-ppcre :iterate :alexandria :anaphora :metabang-bind))

(in-package :day20)

(defun ints (line) 
  (mapcar #'parse-integer (all-matches-as-strings "-?\\d+" line)))

(defun read-syms (line &optional (sep " "))
  (let (*read-eval*)
    (mapcar #'read-from-string (split sep line))))

(defun read-map ()
  (let* ((mp (make-hash-table :test 'equal))
         start
         end
         (portals (make-hash-table :test 'equal)))
    (labels ((add-labelled-coord (i j label)
;               (format t "LABEL ~a~%" label)
               (when (string= label "AA")
                 (setf start (cons i j)))
               (when (string= label "ZZ")
                 (setf end (cons i j)))
               (setf (gethash (cons i j) mp) label)
               (push (cons i j) (gethash label portals))))
      (iter (for line in-file "input20" using #'read-line)
        (for line-p previous line)
        (for line-pp previous line-p)
        (for i from 0)
        (iter (for c in-string line)
              (for c-p previous c)
              (for c-pp previous c-p)
              (for j index-of-vector line)
              (when (char= c #\.)
                (cond ((and c-p c-pp (upper-case-p c-p) (upper-case-p c-pp))
                       (let ((label (coerce (list c-pp c-p) 'string)))
                         (add-labelled-coord i j label)))
                      ((and line-p line-pp (upper-case-p (aref line-p j))
                            (upper-case-p (aref line-pp j)))
                       (let ((label (coerce (list (aref line-pp j) (aref line-p j)) 'string)))
                         (add-labelled-coord i j label)))
                      (t (setf (gethash (cons i j) mp) (format nil "~a ~a" i j)))))
              (when (and c-pp c-p (char= c-pp #\.) (upper-case-p c-p) (upper-case-p c))
                (let ((label (coerce (list c-p c) 'string)))
                  (add-labelled-coord i (- j 2) label)))
              (when (and line-pp line-p (char= (aref line-pp j) #\.) 
                         (upper-case-p (aref line j))
                         (upper-case-p (aref line-p j)))
                (add-labelled-coord (- i 2) j
                                    (coerce (list (aref line-p j) (aref line j)) 'string))))
        (finally (return (progn
;                           (format t "END ~a~%" end)
;                           (format t "PORTALS ~a~%" (hash-table-alist portals))
                           (list mp portals start end))))))))

(defun neighbours (coord mp portals)
  (let (nbrs
        (i (car coord))
        (j (cdr coord)))
    (awhen (gethash (gethash coord mp) portals)
;      (format t "PORTAL NBR ~a~%" it)
      (iter (for other in it)
            (when (not (equal other coord))
              (push other nbrs))))
    (when (gethash (cons (- i 1) j) mp)
      (push (cons (- i 1) j) nbrs))
    (when (gethash (cons (+ i 1) j) mp)
      (push (cons (+ i 1) j) nbrs))
    (when (gethash (cons i (- j 1)) mp)
      (push (cons i (- j 1)) nbrs))
    (when (gethash (cons i (+ j 1)) mp)
      (push (cons i (+ j 1)) nbrs))
;    (format t "NBRS ~a~%" nbrs)
    nbrs))

(defun answer-1 ()
  (iter (with (mp portals start end) = (read-map))
        (with q = (make-queue (cons start 0)))
        (with seen = (alist-hash-table (list (cons start "AA")) :test 'equal))
        (while (non-empty q))
;        (format t "Q ~a~%" q)
        (for (coord . moves-to) = (poll q))
;        (format t "COORD ~a LABEL ~a~%" coord (gethash coord mp))
        (when (equal coord end)
          (return moves-to))
        (iter (for nbr in (neighbours coord mp portals))
              (when (not (gethash nbr seen))
                (setf (gethash nbr seen) t)
                (enqueue (cons nbr (+ moves-to 1)) q)))))

(defun recursive-neighbours (coord level mp portals)
  (let (nbrs
        (i (car coord))
        (j (cdr coord)))
    (awhen (gethash (gethash coord mp) portals)
;      (format t "PORTAL NBR ~a~%" it)
      (iter (for other in it)
            (when (not (equal other coord))
              (push (list (car other) (cdr other) (+ level 1)) nbrs))))
    (when (gethash (cons (- i 1) j) mp)
      (push (list (- i 1) j level) nbrs))
    (when (gethash (cons (+ i 1) j) mp)
      (push (list (+ i 1) j level) nbrs))
    (when (gethash (cons i (- j 1)) mp)
      (push (list i (- j 1) level) nbrs))
    (when (gethash (cons i (+ j 1)) mp)
      (push (list i (+ j 1) level) nbrs))
;    (format t "NBRS ~a~%" nbrs)
    nbrs))

(defun answer-2 ()
  (iter (with (mp portals start end) = (read-map))
        (with q = (make-queue (cons start 0)))
        (with seen = (alist-hash-table (list (cons start "AA")) :test 'equal))
        (while (non-empty q))
                                        ;        (format t "Q ~a~%" q)
        (for (coord . moves-to) = (poll q))
                                        ;        (format t "COORD ~a LABEL ~a~%" coord (gethash coord mp))
        (when (equal coord end)
          (return moves-to))
        (iter (for nbr in (neighbours coord mp portals))
              (when (not (gethash nbr seen))
                (setf (gethash nbr seen) t)
                (enqueue (cons nbr (+ moves-to 1)) q)))))
