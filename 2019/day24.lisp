(ql:quickload :cl-ppcre)
(ql:quickload :iterate)
(ql:quickload :anaphora)
(ql:quickload :metabang-bind)
(ql:quickload :alexandria)

(defpackage :day24
  (:use :cl :cl-ppcre :iterate :alexandria :anaphora :metabang-bind))

(in-package :day24)

(defun ints (line) 
  (mapcar #'parse-integer (all-matches-as-strings "-?\\d+" line)))

(defun read-syms (line &optional (sep " "))
  (let (*read-eval*)
    (mapcar #'read-from-string (split sep line))))

(defun read-lines ()
  (coerce (iter (for line in-file "input24" using #'read-line)
                (collect line)) 'vector))

(defmacro grid-at (r c grid)
  `(aref (aref ,grid ,r) ,c))

(defun neighbours (r c grid)
  (let ((neighbours 0))
    (when (and (> r 0) (char= (grid-at (- r 1) c grid) #\#))
      (incf neighbours))
    (when (and (> c 0) (char= (grid-at r (- c 1) grid) #\#))
      (incf neighbours))
    (when (and (< r (- (length grid) 1)) (char= (grid-at (+ r 1) c grid) #\#))
      (incf neighbours))
    (when (and (< c (- (length (aref grid 0)) 1)) (char= (grid-at r (+ c 1) grid) #\#))
      (incf neighbours))
    neighbours))

(defun biodiversity-rating (grid)
  (iter (with pow = 0)
        (with rating = 0)
        (for row in-vector grid)
        (iter (for ch in-vector row)
              (when (char= ch #\#)
                (incf rating (expt 2 pow)))
              (incf pow))
        (finally (return rating))))

(defun tick ()
  (let ((seen (alist-hash-table (list (cons (map 'list #'identity (read-lines)) t)) :test 'equal)))
    (iter (for grid first (read-lines) then new-grid)
          (for new-grid first (map 'vector #'copy-seq grid) then (map 'vector #'copy-seq new-grid))
;          (format t "~{~a~%~}~%" (map 'list #'identity grid))
          (iter (for row in-vector grid)
                (for r index-of-vector grid)
                (iter (for c index-of-vector row)
;                      (format t "~a ~a~%" (cons r c) (neighbours r c grid))
                      (if (or (and (char= (grid-at r c grid) #\#)
                                   (= (neighbours r c grid) 1))
                              (and (char= (grid-at r c grid) #\.)
                                   (<= 1 (neighbours r c grid) 2)))
                          (setf (grid-at r c new-grid) #\#)
                          (setf (grid-at r c new-grid) #\.))))
          (for hash-entry = (map 'list #'identity new-grid))
;          (format t "~{~a~%~}~%" hash-entry)
          (until (gethash hash-entry seen))
          (setf (gethash hash-entry seen) t)
          (finally (return (list (biodiversity-rating new-grid) hash-entry))))))


(defun answer-1 () (car (tick)))

(defun recusive-neighbours (r c up-one grid down-one)
  (let ((neighbours 0))
    (when (and (> r 0) (char= (grid-at (- r 1) c grid) #\#))
      (incf neighbours))
    (when (and (> c 0) (char= (grid-at r (- c 1) grid) #\#))
      (incf neighbours))
    (when (and (< r (- (length grid) 1)) (char= (grid-at (+ r 1) c grid) #\#))
      (incf neighbours))
    (when (and (< c (- (length (aref grid 0)) 1)) (char= (grid-at r (+ c 1) grid) #\#))
      (incf neighbours))
    (when (and up-one (or (and (= r 0) (char= (grid-at 1 2 up-one) #\#))
                          (and (= r 4) (char= (grid-at 3 2 up-one) #\#))
                          (and (= c 0) (char= (grid-at 2 1 up-one) #\#))
                          (and (= c 4) (char= (grid-at 2 3 up-one) #\#))))
      (incf neighbours))
    (when (and down-one (= r 1) (= c 2))
      (iter (for dc from 0 to 4)
            (when (char= (grid-at 0 dc down-one) #\#)
              (incf neighbours))))
    (when (and down-one (= r 3) (= c 2))
      (iter (for dc from 0 to 4)
            (when (char= (grid-at 4 dc down-one) #\#)
              (incf neighbours))))
    (when (and down-one (= r 2) (= c 1))
      (iter (for dr from 0 to 4)
            (when (char= (grid-at dr 0 down-one) #\#)
              (incf neighbours))))
    (when (and down-one (= r 2) (= c 3))
      (iter (for dr from 0 to 4)
            (when (char= (grid-at dr 4 down-one) #\#)
              (incf neighbours))))
    neighbours))

(defun new-grid (up-one middle down-one)
  (iter (with new-grid = (map 'vector #'copy-seq middle))
        (iter (for row in-vector middle)
              (for r index-of-vector middle)
              (iter (for c index-of-vector row)
                    (when (or (/= r 2) (/= c 2))
                      (let ((nbrs (recusive-neighbours r c up-one middle down-one)))
                        (if (or (and (char= (grid-at r c middle) #\#)
                                     (= nbrs 1))
                                (and (char= (grid-at r c middle) #\.)
                                     (<= 1 nbrs 2)))
                            (setf (grid-at r c new-grid) #\#)
                            (setf (grid-at r c new-grid) #\.))))))))



(defun recursive-tick ()
  (iter (with levels = (list (read-lines)))
        (iter (for rest first levels then (cdr rest))
              (for middle = (car rest))
              (for up-one previous middle)
              (for down-one (cadr rest))
              (when (not up-one)))))
