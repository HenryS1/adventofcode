(ql:quickload :cl-ppcre)
(ql:quickload :iterate)
(ql:quickload :anaphora)
(ql:quickload :metabang-bind)
(ql:quickload :alexandria)

(defpackage :day24
  (:use :cl :cl-ppcre :iterate :alexandria :anaphora :metabang-bind))

(in-package :day24)

(defun ints (line) 
  (mapcar #'parse-integer (all-matches-as-strings "-?\\d+" line)))

(defun read-syms (line &optional (sep " "))
  (let (*read-eval*)
    (mapcar #'read-from-string (split sep line))))

(defun read-lines ()
  (coerce (iter (for line in-file "input24" using #'read-line)
                (collect line)) 'vector))

(defmacro grid-at (r c grid)
  `(aref (aref ,grid ,r) ,c))

(defun neighbours (r c grid)
  (let ((neighbours 0))
    (when (and (> r 0) (char= (grid-at (- r 1) c grid) #\#))
      (incf neighbours))
    (when (and (> c 0) (char= (grid-at r (- c 1) grid) #\#))
      (incf neighbours))
    (when (and (< r (- (length grid) 1)) (char= (grid-at (+ r 1) c grid) #\#))
      (incf neighbours))
    (when (and (< c (- (length (aref grid 0)) 1)) (char= (grid-at r (+ c 1) grid) #\#))
      (incf neighbours))
    neighbours))

(defun biodiversity-rating (grid)
  (iter (with pow = 0)
        (with rating = 0)
        (for row in-vector grid)
        (iter (for ch in-vector row)
              (when (char= ch #\#)
                (incf rating (expt 2 pow)))
              (incf pow))
        (finally (return rating))))

(defun tick ()
  (let ((seen (alist-hash-table (list (cons (map 'list #'identity (read-lines)) t)) :test 'equal)))
    (iter (for grid first (read-lines) then new-grid)
          (for new-grid first (map 'vector #'copy-seq grid) then (map 'vector #'copy-seq new-grid))
          (iter (for row in-vector grid)
                (for r index-of-vector grid)
                (iter (for c index-of-vector row)
                      (if (or (and (char= (grid-at r c grid) #\#)
                                   (= (neighbours r c grid) 1))
                              (and (char= (grid-at r c grid) #\.)
                                   (<= 1 (neighbours r c grid) 2)))
                          (setf (grid-at r c new-grid) #\#)
                          (setf (grid-at r c new-grid) #\.))))
          (for hash-entry = (map 'list #'identity new-grid))
          (until (gethash hash-entry seen))
          (setf (gethash hash-entry seen) t)
          (finally (return (list (biodiversity-rating new-grid) hash-entry))))))


(defun answer-1 () (car (tick)))

(defun recursive-neighbours (r c up-one grid down-one)
  (let ((neighbours 0))
    (when (and (> r 0) (char= (grid-at (- r 1) c grid) #\#))
      (incf neighbours))
    (when (and (> c 0) (char= (grid-at r (- c 1) grid) #\#))
      (incf neighbours))
    (when (and (< r (- (length grid) 1)) (char= (grid-at (+ r 1) c grid) #\#))
      (incf neighbours))
    (when (and (< c (- (length (aref grid 0)) 1)) (char= (grid-at r (+ c 1) grid) #\#))
      (incf neighbours))
    (when up-one 
      (when (and (= r 0) (char= (grid-at 1 2 up-one) #\#))
        (incf neighbours))
      (when (and (= r 4) (char= (grid-at 3 2 up-one) #\#))
        (incf neighbours))
      (when (and (= c 0) (char= (grid-at 2 1 up-one) #\#))
        (incf neighbours))
      (when (and (= c 4) (char= (grid-at 2 3 up-one) #\#))
        (incf neighbours)))
    (when (and down-one (= r 1) (= c 2))
      (iter (for dc from 0 to 4)
            (when (char= (grid-at 0 dc down-one) #\#)
              (incf neighbours))))
    (when (and down-one (= r 3) (= c 2))
      (iter (for dc from 0 to 4)
            (when (char= (grid-at 4 dc down-one) #\#)
              (incf neighbours))))
    (when (and down-one (= r 2) (= c 1))
      (iter (for dr from 0 to 4)
            (when (char= (grid-at dr 0 down-one) #\#)
              (incf neighbours))))
    (when (and down-one (= r 2) (= c 3))
      (iter (for dr from 0 to 4)
            (when (char= (grid-at dr 4 down-one) #\#)
              (incf neighbours))))
    neighbours))

(defun new-grid (up-one middle down-one)
  (iter (with new-grid = (map 'vector #'copy-seq middle))
        (for row in-vector middle)
        (for rw from 0)
        (for r index-of-vector middle)
        (iter (for c index-of-vector row)
              (when (or (/= r 2) (/= c 2))
                (let ((nbrs (recursive-neighbours r c up-one middle down-one)))
                  (if (or (and (char= (grid-at r c middle) #\#)
                               (= nbrs 1))
                          (and (char= (grid-at r c middle) #\.)
                               (<= 1 nbrs 2)))
                      (progn 
                        (setf (grid-at r c new-grid) #\#))
                      (setf (grid-at r c new-grid) #\.)))))
        (finally (return new-grid))))

(defun make-new-grid (grid)
  (map 'vector (lambda (row) (map 'string (lambda (c) (declare (ignore c)) #\.) row)) grid))

(defun non-empty (grid)
  (some (lambda (row) (find #\# row)) grid))

(defun recursive-tick (levels)
  (iter (with empty-grid = (make-new-grid (car levels)))
        (for rest first levels then (cdr rest))
        (while rest)
        (for middle = (car rest))
        (for up-one previous middle)
        (for down-one = (cadr rest))
        (when (not up-one)
          (let ((new-first (new-grid nil empty-grid middle)))
            (when (non-empty new-first)
              (collect new-first))))
        (collect (new-grid up-one middle down-one))
        (when (not down-one)
          (for new-last = (new-grid middle empty-grid nil))
          (when (non-empty new-last)
            (collect new-last)))))

(defun format-levels (levels)
  (let ((result (mapcar (lambda (l) (coerce l 'list)) levels)))
    (iter (for l in result)
          (format t "~{~a~%~}~%" l))))

(defun recursive-bugs (n)
  (iter (for levels first (list (read-lines)) then (recursive-tick levels))
        (for _ from 1 to n)
        (finally (return levels))))

(defun count-bugs (levels)
  (iter (for level in levels)
        (sum (reduce #'+ (map 'vector 
                              (lambda (row) (count-if (lambda (c) (char= c #\#)) row)) level)))))

(defun answer-2 ()
  (count-bugs (recursive-bugs 200)))
