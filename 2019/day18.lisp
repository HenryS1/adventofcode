(load "../2018/queue.lisp")
(load "../2018/priority-queue.lisp")
(ql:quickload :cl-ppcre)
(ql:quickload :iterate)
(ql:quickload :anaphora)
(ql:quickload :metabang-bind)
(ql:quickload :alexandria)

(defpackage :day18
  (:use :cl :cl-ppcre :iterate :alexandria :anaphora :metabang-bind))

(in-package :day18)

(defun ints (line) 
  (mapcar #'parse-integer (all-matches-as-strings "-?\\d+" line)))

(defun read-syms (line &optional (sep " "))
  (let (*read-eval*)
    (mapcar #'read-from-string (split sep line))))

(defun read-map ()
  (map 'vector #'identity 
       (iter (for line in-file "inputt" using #'read-line)
             (collect line))))

(defun map-at (mp r c)
  (aref (aref mp r) c))

(defun rows (mp)
  (length mp))

(defun cols (mp) 
  (length (aref mp 0)))

(defun find-keys (mp)
  (iter outer
        (for line in-vector mp)
        (for r from 0)
        (iter (for c index-of-vector line)
              (for ch in-string line)
              (when (lower-case-p ch)
                (in outer (collect (cons r c)))))))

(defun in-bounds (candidate mp)
  (and (<= 0 (car candidate) (- (rows mp) 1))
       (<= 0 (cdr candidate) (- (cols mp) 1))))

(defun eligible (mp unlocked)
  (lambda (candidate)
   (and (in-bounds candidate mp)
        (let ((sq (map-at mp (car candidate) (cdr candidate))))
          (or 
           (char= sq #\.)
           (lower-case-p sq)
           (and (upper-case-p sq) 
                (find (char-downcase sq) unlocked)))))))

(defun neighbours (mp unlocked r c)
  (let ((candidates (list (cons (+ r 1) c) (cons (- r 1) c) 
                          (cons r (+ c 1)) (cons r (- c 1)))))
    (remove-if-not (eligible mp unlocked) candidates)))

(defun eligible-full (mp)
  (lambda (candidate)
   (and (in-bounds candidate mp)
        (let ((sq (map-at mp (car candidate) (cdr candidate))))
          (or 
           (char= sq #\.)
           (char= sq #\@)
           (alpha-char-p sq))))))

(defun neighbours-full (mp r c)
  (let ((candidates (list (cons (+ r 1) c) (cons (- r 1) c) 
                          (cons r (+ c 1)) (cons r (- c 1)))))
    (remove-if-not (eligible-full mp) candidates)))

(defun explore (coord mp moves-so-far unlocked)
  (iter (with q = (make-queue (cons coord 0)))
        (with seen = (alist-hash-table (list (cons coord t)) :test 'equal))
        ;(with keys-seen = (list))
        (while (not (empty q)))
        (for blah = (peek q))
        (for ((r . c) . moves-to) = (poll q))
        (when (and (lower-case-p (map-at mp r c)) 
                   (not (find (map-at mp r c) unlocked)))
          (collect (cons (cons r c) (+ moves-to moves-so-far)) into keys-seen))
        (iter (for nbr in (neighbours mp unlocked r c))
              (when (not (gethash nbr seen))
                (setf (gethash nbr seen) t)
                (enqueue (cons nbr (+ moves-to 1)) q)))
        (finally (return keys-seen))))

(defun edges-from (coord mp)
  (iter outer
        (with q = (make-queue (cons coord 0)))
        (with seen = (alist-hash-table (list (cons coord t)) :test 'equal))
        (while (not (empty q)))
        (for ((r . c) . moves-to) = (poll q))       
        (iter (for nbr in (neighbours-full mp r c))
              (for sq = (map-at mp (car nbr) (cdr nbr)))
              (when (not (gethash nbr seen))
                (setf (gethash nbr seen) t)
                (when (alpha-char-p sq)
                  (in outer (collect (cons nbr (+ moves-to 1)) into keys-seen)))
                (when (not (upper-case-p sq))
                  (enqueue (cons nbr (+ moves-to 1)) q))))
        (finally (return-from outer keys-seen))))

(defun key-locations (mp)
  (iter outer 
        (for row in-vector mp)
        (for r from 0)
        (iter (for c index-of-vector row)
              (when (lower-case-p (map-at mp r c))
                (in outer (collect (cons (map-at mp r c) (cons r c))))))))

(defun locations (mp)
  (iter outer 
        (for row in-vector mp)
        (for r from 0)
        (iter (for c index-of-vector row)
              (when (alpha-char-p (map-at mp r c))
                (in outer (collect (cons r c) into result))))
        (finally (return-from outer (cons (find-start-coord mp) result)))))

(defun total-distance-from (coord key-locations)
  (iter (with (r . c) = coord)
        (for (sq . (r-kl . c-kl)) in key-locations)
        (sum (+ (abs (- r-kl r))  (abs (- c-kl c))))))

(defun make-graph (mp)
  (iter (with graph = (make-hash-table :test 'equal))
        (for loc in (locations mp))
        (setf (gethash loc graph) (edges-from loc mp))
        (finally (return graph))))

(defun priority (key-locations one)
  (bind (((unlocked moves-to coord) one))
    (let ((unseen (remove-if (lambda (e) (find (car e) unlocked)) key-locations)))
      (+ moves-to (total-distance-from coord unseen)))))

(defun distance-to-goal (key-locations)
  (lambda (one other)
    (< (priority key-locations one) (priority key-locations other))))

(defun find-start-coord (mp)
  (iter outer
        (for row in-vector mp)
        (for r from 0)
        (iter (for c index-of-vector row)
              (when (char= (map-at mp r c) #\@)
                (return-from outer (cons r c))))))

(defun find-best-path (mp)
  (let* ((start-coord (find-start-coord mp))
         (key-locs (key-locations mp))
         (pq (make-pq (distance-to-goal key-locs))))
    (insert-pq (list (list) 0 start-coord) pq)
    (iter (while (not (pq-empty pq)))
          (for (unlocked moves-so-far coord) = (pop-pq pq))
          (format t "UNLOCKED ~a MOVES-SO-FAR ~a~%" unlocked moves-so-far)
          (until (= (length key-locs) (length unlocked)))
          (iter (for (key-coord . moves-to) in (explore coord mp moves-so-far 
                                                        unlocked))
                (insert-pq (list (cons (map-at mp (car key-coord) (cdr key-coord)) unlocked)
                               (+ moves-so-far moves-to)
                               key-coord) pq))
          (finally (return moves-so-far)))))

(defun explore-to-end (mp)
  (let ((start-coord (find-start-coord mp))
        (target-len (length (key-locations mp)))
        (best-total 100000000000))
    (labels ((rec (coord moves-so-far unlocked)
               (format t "UNLOCKED ~a~%" unlocked)
               ;; (format t "COORD ~a CHAR ~a UNLOCKED ~a MOVES ~a~%"
               ;;         coord (map-at mp (car coord) (cdr coord)) unlocked moves-so-far)
               (if (= (length unlocked) target-len)
                   (when (< moves-so-far best-total)
                     (format t "NEW BEST ~a~%" moves-so-far)
                     (setf best-total moves-so-far))
                   (iter (for (next-coord . moves-to) 
                              in (explore coord mp moves-so-far unlocked))
                         (when (< (+ moves-so-far moves-to) best-total)
                           (rec next-coord (+ moves-so-far moves-to) 
                                (cons (map-at mp (car next-coord) (cdr next-coord))
                                      unlocked)))))))
      (rec start-coord 0 nil))))

(defun find-reachable (start graph mp unlocked)
;  (format t "UNLOCKED ~a~%" unlocked)
  (iter (with pq = (let ((q (make-pq (lambda (one other) (< (car one) (car other))))))
                     (insert-pq (cons 0 start) q) q))
        (with distance-to = (make-hash-table :test 'equal))
        (while (not (pq-empty pq)))
        (for (moves-to . coord) = (pop-pq pq))
;        (format t "COORD ~a~%" coord)
        (when (not (gethash coord distance-to))
;          (format t "HERE~%")
          (setf (gethash coord distance-to) moves-to)
          (iter (for (nbr . dist) in (gethash coord graph))
                (for sq = (map-at mp (car nbr) (cdr nbr)))
;                (format t "NBR ~a SQ ~a~%" nbr sq)
                (when (and (or (lower-case-p sq) 
                               (find (char-downcase sq) unlocked)))
                  (insert-pq (cons (+ moves-to dist) nbr) pq))))
        (finally (return (remove-if-not (lambda (e) 
                                          (let ((sq (map-at mp (caar e) (cdar e))))
                                            (and (not (find sq unlocked))
                                                 (lower-case-p sq))))
                                        (hash-table-alist distance-to))))))

(defun find-reachable-estimate (start graph mp unlocked)
;  (format t "UNLOCKED ~a~%" unlocked)
  (iter (with pq = (let ((q (make-pq (lambda (one other) (< (car one) (car other))))))
                     (insert-pq (cons 0 start) q) q))
        (with distance-to = (make-hash-table :test 'equal))
        (while (not (pq-empty pq)))
        (for (moves-to . coord) = (pop-pq pq))
;        (format t "COORD ~a~%" coord)
        (when (not (gethash coord distance-to))
;          (format t "HERE~%")
          (setf (gethash coord distance-to) moves-to)
          (iter (for (nbr . dist) in (gethash coord graph))
                (for sq = (map-at mp (car nbr) (cdr nbr)))
;                (format t "NBR ~a SQ ~a~%" nbr sq)
                (when (and (or (lower-case-p sq) 
                               (find (char-downcase sq) *all*)))
                  (insert-pq (cons (+ moves-to dist) nbr) pq))))
        (finally (return (remove-if-not (lambda (e) 
                                          (let ((sq (map-at mp (caar e) (cdar e))))
                                            (and (not (find sq unlocked))
                                                 (lower-case-p sq))))
                                        (hash-table-alist distance-to))))))

(defparameter *all* '(#\a #\b #\c #\d #\e #\f #\g #\h #\i #\j #\k #\l #\m #\n #\o #\p #\q #\r #\s
 #\t #\u #\v #\w #\x #\y #\z))

(defun estimated-moves-remaining (coord key-locations unlocked)
  (iter (for (sq . (r . c)) in key-locations)
        (when (not (find sq unlocked))
          (sum (+ (abs (- (car coord) r)) (abs (- (cdr coord) c)))))))

(defun sharp-estimated-moves-remaining (coord graph mp unlocked)
  (iter (for (crd . mvs-to) in (find-reachable-estimate coord graph mp unlocked))
        (sum (+ (abs (- (car crd) (car coord))) (abs (- (cdr crd) (cdr coord)))))))

(defun explore-compressed (mp)
  (let* ((graph (make-graph mp))
         (kls (key-locations mp))
         (target-len (length kls))
         (best-total 100000000000))
    (labels ((rec (coord moves-so-far unlocked)
;               (format t "UNLOCKED ~a~%" unlocked)
               (if (= (length unlocked) target-len)
                   (when (< moves-so-far best-total)
                     (format t "NEW BEST ~a~%" moves-so-far)
                     (setf best-total moves-so-far))
                   (iter (with reachable = (sort (find-reachable coord graph mp unlocked)
                                                 (lambda (one other) (< (cdr one) (cdr other)))))
;                         (format t "REACHABLE ~a~%" reachable)
                         (for (next-coord . moves-to) in reachable)
;                         (format t "NEXT COORD ~a~%" next-coord)
                         (when (< (+ (+ moves-so-far moves-to)
                                     (estimated-moves-remaining next-coord kls unlocked))
                                  best-total)
                           (rec next-coord (+ moves-so-far moves-to)
                                (cons (map-at mp (car next-coord) (cdr next-coord)) 
                                      unlocked)))))
;               (format t "COORD ~a~%" coord)
;               (format t "UNLOCKED ~a~%" unlocked)
               ))
      (rec (find-start-coord mp) 0 nil))))

(defun find-key-coords (mp)
  (iter outer
        (for row in-vector mp)
        (for r from 0)
        (iter (for ch in-string row)
              (for c from 0)
              (when (lower-case-p ch)
                (in outer (collect (cons r c)))))))

(defun optimistic-distances-between (mp)
  (let ((keys (find-key-coords mp))
        (distances (make-hash-table :test 'equal)))
    (labels ((find-distances (start)
               (iter (with q = (make-queue (cons start 0)))
                     (with seen = (alist-hash-table (list (cons start t)) :test 'equal))
                     (while (non-empty q))
                     (for (current . dist) = (poll q))
                     (when (find current keys :test 'equal)
                       (push (cons current dist) (gethash start distances)))
;                     (format t "START ~a CURRENT ~a DIST ~a~%" start current dist)
                     (for (r . c) = current)
                     (iter (for nbr in (neighbours-full mp r c))
                           (when (not (gethash nbr seen))
                             (setf (gethash nbr seen) t)
                             (enqueue (cons nbr (+ dist 1)) q))))))
      (iter (for k in keys)
            (find-distances k))
      (lambda (one other) (cdr (find-if (lambda (e) (equal (car e) one)) 
                                        (gethash other distances)))))))

(defun take (i l)
  (iter (for j from 1 to i) (for e in l) (collect e)))

(defun drop (i l)
  (iter (for j from 0 to i) (for rest first l then (cdr rest)) (finally (return rest))))

(defun heaps-algorithm (l callback)
  (labels ((rec (k)
             (if (= k 1) 
                 (funcall callback l)
                 (progn
                   (rec (- k 1))
                   (iter (for i from 0 to (- k 2))
                         (if (evenp k) 
                             (rotatef (aref l i) (aref l (- k 1)))
                             (rotatef (aref l 0) (aref l (- k 1))))
                         (rec (- k 1)))))))
    (rec (length l))))

(defun max-pair-by-distance (keys distances)
  (iter (with dist = 0)
        (with best-pair = nil)
        (for i from 0 to (- (length keys) 2))
        (for k1 = (aref keys i))
        (iter (for j from (+ i 1) to (- (length keys) 1))
              (for k2 = (aref keys j))
              (let ((new-dist (funcall distances k1 k2)))
                (and (not (equal k1 k2)) (> new-dist dist))
                (setf dist new-dist
                      best-pair (list k1 k2))))
        (finally (return best-pair))))

(defun brute-force-tsp (distances selected-keys)
  (let ((best-cost (- (expt 2 31) 1)))
    (labels ((check-cost (ordering)
               (iter (for i from 0 to (- (length ordering) 2))
                     (for j from 1 to (- (length ordering) 1))
;                     (format t "CURRENT ~a~%" (aref ordering i))
;                     (format t "DISTS ~a~%" (gethash (aref ordering i) distances))
                     (sum (funcall distances (aref ordering i) (aref ordering j)) into cost)
                     (finally (return (if (< cost best-cost) (setf best-cost cost)))))))
      (heaps-algorithm selected-keys #'check-cost)
      best-cost)))

(defun point-maximizing-spread (keys chosen distances)
  (iter (with best = 0)
        (with best-key = nil)
        (for key in-vector keys)
        (when (not (find key chosen :test 'equal))
          (for curr-dist = (iter (for c in chosen)
                                 (sum (funcall distances key c))))
          (when (> curr-dist best)
            (setf best curr-dist)
            (setf best-key key)))
        (finally (return best-key))))

(defun find-spread-out-keys (keys distances n)
  (bind ((chosen (max-pair-by-distance keys distances)))
    (decf n 2)
    (iter (while (> n 0))
          (push (point-maximizing-spread keys chosen distances) chosen)
          (decf n))
    chosen))

(defparameter *inf* (- (expt 2 31) 1))

(defun find-connections (start keys-and-doors mp)
  (iter (with q = (make-queue (cons start 0)))
        (with seen = (alist-hash-table (list (cons start t)) :test 'equal))
        (with connections = (make-hash-table :test 'equal) ;; (alist-hash-table 
                            ;;  (mapcar (lambda (kd) (cons kd *inf*)) 
                            ;;          (remove-if (lambda (kd) (equal kd start))
                            ;;                     keys-and-doors)) :test 'equal)
              )
        (while (non-empty q))
        (for (current . dist) = (poll q))
        (for (r . c) = current)
        (iter (for nbr in (neighbours-full mp r c))
              (when (not (gethash nbr seen))
                (let ((ch (map-at mp (car nbr) (cdr nbr))))
                  (setf (gethash nbr seen) t)
                  (when (not (alpha-char-p ch))
                    (enqueue (cons nbr (+ dist 1)) q))
                  (when (alpha-char-p ch)
                    (setf (gethash nbr connections) (+ dist 1))))))
        (finally (return (sort (iter (for (k v) in-hashtable connections)
                                     (collect (cons k v)))
                               (lambda (one other) (< (cdr one) (cdr other))))))))

(defun find-keys-and-doors (mp)
  (iter outer 
        (for row in-vector mp)
        (for r from 0)
        (iter (for c index-of-vector row)
              (when (alpha-char-p (map-at mp r c))
                (in outer (collect (cons r c) into result))))
        (finally (return-from outer result))))

(defun make-tsp-graph (mp)
  (let ((keys-and-doors (find-keys-and-doors mp))
        (start (find-start-coord mp))
        (graph (make-hash-table :test 'equal)))
    (iter (for kd in keys-and-doors)
          (setf (gethash kd graph) (find-connections kd keys-and-doors mp)))
    (setf (gethash start graph) (find-connections start keys-and-doors mp))
    graph))

(defun find-in-map (mp coord)
  (map-at mp (car coord) (cdr coord)))

(defun comp-by-seen (seen)
  (lambda (one other)
    (or (not (find (car one) seen :test 'equal))
        (not (find (car other) seen :test 'equal)))))

(defun travel-between (start end unlocked remaining graph mp)
  (let ((q (make-pq (lambda (a b) (< (car a) (car b)))))
        (seen (make-hash-table :test 'equal)))
    (insert-pq (list 0 start unlocked) q)
    (iter (while (not (pq-empty q)))
          (for (moves current curr-unlocked curr-remaining) = (pop-pq q))
          (when (gethash current seen)
            (next-iteration))
          (setf (gethash current seen) t)
          (when (equal current end)
            (return-from travel-between (list moves curr-unlocked curr-remaining)))
          (iter (for (other . dist) in (gethash current graph))
;                (format t "OTHER ~a~%" other)
                (when (not (gethash other seen))
                  (for ch = (find-in-map mp other))
                  (when (or (lower-case-p ch) (find ch unlocked))
                    (for next-unlocked = (if (lower-case-p ch)
                                             (adjoin (char-upcase ch) unlocked)
                                             unlocked))
                                        ;                  (format t "OTHER ~a~%" other)
                   (for next-remaining = (remove other remaining :test 'equal :count 1))
                   (insert-pq (list (+ moves dist) other next-unlocked next-remaining) q))))
          (finally (return (list *inf* curr-unlocked curr-remaining))))))

(defun estimate-remaining-cost (remaining graph)
  (iter (for rm in remaining)
        (for cost = (cdar (gethash rm graph)))
        (maximize cost into mx)
        (sum cost into sm)
        (finally (return (if (and sm mx)
                             (- sm mx)
                             0)))))

(defun branch-and-bound (graph mp)
  (let ((bound *inf*)
        (num-keys (length (find-keys mp)))) 
    (declare (optimize (speed 3) (safety 0)))
    (labels ((rec (current remaining moves-so-far unlocked)
               (declare (fixnum moves-so-far bound))
;               (format t "CURRENT ~a MOVES SO FAR ~a~%" current moves-so-far)
               (cond ((> moves-so-far bound) nil)
                     ((= (length unlocked) num-keys)
                      (when (< moves-so-far bound)
                        (format t "NEW BEST ~a~%" moves-so-far)
                        (setf bound moves-so-far)))
                     (t (iter (for next in remaining)
;                              (format t "NEXT ~a~%" next)
                              (for ((the fixnum next-moves) next-unlocked next-remaining) = 
                                   (travel-between current next unlocked remaining graph mp))
;                              (format t "NEXT MOVES ~a~%" next-moves)
                              (for chr = (find-in-map mp next))
                              (when (<= (+ next-moves moves-so-far 
                                           (estimate-remaining-cost next-remaining graph)) bound)
                                (rec next next-remaining
                                     (+ next-moves moves-so-far) next-unlocked)))))))
      (rec (find-start-coord mp) (find-keys mp) 0 nil)
      bound)))

(defun connected-through-doors (start mp)
  (iter outer
        (with q = (make-queue (list start 0 nil nil)))
        (with seen = (alist-hash-table (list (cons start t)) :test 'equal))
        (while (non-empty q))
        (for (current dist keys doors) = (poll q))
        (iter (for nbr in (neighbours-full mp (car current) (cdr current)))
              (when (not (gethash nbr seen))
                (setf (gethash nbr seen) t)
                (for ch = (find-in-map mp nbr))
                (for next-doors = (if (upper-case-p ch)
                                      (cons nbr doors)
                                      doors))
                (for next-keys = (if (lower-case-p ch)
                                     (cons nbr keys)
                                     keys))
                (enqueue (list nbr (+ dist 1) next-keys next-doors) q)
                (when (lower-case-p ch)
                  (in outer (collect (list nbr (+ dist 1) next-keys next-doors))))))))

(defun make-reachable-graph (mp)
  (iter (with locs = (locations mp))
        (with graph = (make-hash-table :test 'equal))
        (for loc in locs)
        (setf (gethash loc graph) (connected-through-doors loc mp))
        (finally (return graph))))

(defun entry-priority (num-keys)
  (lambda (entry)
    (car entry)
    (+ (car entry) 
       (* 100 (- num-keys (length (cadr entry)))))))

(defun a-star (mp)
  (let* ((graph (make-reachable-graph mp))
         (start (find-start-coord mp))
         (num-keys (length (find-keys mp)))
         (prty (entry-priority num-keys))
         (q (make-pq (lambda (one other) (< (funcall prty one)
                                            (funcall prty other))))))
    (insert-pq (list 0 nil start ;(find-keys mp)
                     ) q)
    (iter (while (not (pq-empty q)))
          (for (moves-so-far unlocked current ;remaining
                             ) = (pop-pq q))
          (format t "CURRENT ~a MOVES ~a~%" (find-in-map mp current) moves-so-far)
          (format t "unlocked ~a~%" unlocked)
          (when (= (length unlocked) num-keys)
            (format t "NEW CANDIDATE ~a~%" moves-so-far))
          (format t "REACHABLE ~a~%" (gethash current graph))
          (iter (for (other dist keys doors) in (gethash current graph))
;                (format t "OTHER ~a REMAINING ~a~%" other remaining)
                (when (not (find other unlocked :test 'equal))
                  (for ch = (find-in-map mp other))
                  (format t "OTHER ~a DOORS ~a~%" ch doors)
                  (when (subsetp doors unlocked :test 'equal)
                                        ;                        (format t "OTHER ~a~%" (find-in-map mp other))
                    ;; (format t "KEYS ~a UNLOCKED ~a~%" keys unlocked)
                    (for next-unlocked = (union keys unlocked :test 'equal))
                    ;; (format t "NEXT UNLOCKED ~a~%" next-unlocked)
                    ;; (for next-remaining = (remove other 
                    ;;                               (set-difference remaining keys :test 'equal)
                    ;;                               :test 'equal))
                                        ;                        (format t "NEXT UNLOCKED ~a~%" next-unlocked)
                                        ;                        (format t "NEXT REMAINING ~a~%" next-remaining)
                    (insert-pq (list (+ moves-so-far dist) 
                                     next-unlocked
                                     other
;                                     next-remaining
                                     ) q)))
                ))))
