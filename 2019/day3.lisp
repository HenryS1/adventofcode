(ql:quickload :cl-ppcre)
(ql:quickload :iterate)
(ql:quickload :ironclad)
(ql:quickload :flexi-streams)
(ql:quickload :anaphora)

(defpackage :day3
  (:use :cl :cl-ppcre :iterate :ironclad :flexi-streams :anaphora))

(in-package :day3)

(defun find-hash (num)
  (let* ((input (format nil "~a" num)))
    (byte-array-to-hex-string (digest-sequence :md5 (string-to-octets input)))))

(defun ints (line)
  (mapcar #'parse-integer (all-matches-as-strings "\\d+" line)))

(defun read-sep-syms (line sep)
  (let (*read-eval*)
    (mapcar #'read-from-string (split sep line))))

(defun read-syms (line)
  (let (*read-eval*)
    (with-input-from-string (s line)
      (iter (for sym in-stream s)
            (collect sym)))))

(defun move (d n current)
  (case d
    (#\U (cons (- (car current) n) (cdr current)))
    (#\D (cons (+ (car current) n) (cdr current)))
    (#\L (cons (car current) (- (cdr current) n)))
    (#\R (cons (car current) (+ (cdr current) n)))))

(defun cons< (one other)
  (or (< (car one) (car other))
      (and (= (car one) (car other))
           (< (cdr one) (cdr other)))))

(defun path (instructions)
  (iter (with current = '(0 . 0))
        (for i in instructions)
        (for d = (aref i 0))
        (for n = (parse-integer i :start 1))
        (for next = (move d n current))
        (collect (sort (list current next) #'cons<))
        (setf current next)))

(defun intersect (l1 l2)
  (destructuring-bind ((x1 . y1) (x2 . y2)) l1
      (destructuring-bind ((x3 . y3) (x4 . y4)) l2
        (let ((r (cond ((= x1 x2 x3 x4)
                      (if (<= y1 y3 y2)
                          (cons x1 y3)
                          (if (<= y1 y4 y2) 
                              (cons x1 y1) nil)))
                     ((= y1 y2 y3 y4)
                      (if (<= x1 x3 x2)
                          (cons x3 y1)
                          (if (<= x1 x4 x2)
                              (cons x1 y1) nil)))
                     ((and (<= x1 x3 x2)
                           (<= y3 y1 y4))
                      (cons x3 y1))
                     ((and (<= x3 x1 x4)
                           (<= y1 y3 y2))
                      (cons x1 y3))
                     (t nil))))
          r))))

(defun manhattan-distance (p1 p2)
  (+ (abs (- (car p1) (car p2))) (abs (- (cdr p1) (cdr p2)))))

(defun other (one l)
  (if (or (= (car one) (caar l))
          (= (cdr one) (cdar l)))
      (car l) 
      (cadr l)))

(defun steps-to (intersection segments)
  (iter (with (x3 . y3) = intersection)
        (for ((x1 . y1) (x2 . y2)) in segments)
        (for s in segments)
        (for current first '(0 . 0) then (other current s))
        (until (or (and (= x1 x2 x3) (<= y1 y3 y2))
                   (and (= y1 y2 y3) (<= y1 y3 y2))))
        (sum (+ (abs (- x1 x2)) (abs (- y1 y2))) into result)
        (finally (return (+ result (manhattan-distance current (cons x3 y3)))))))

(defun intersections (p1 p2)
  (iter outer (for l1 in p1)
        (iter (for l2 in p2)
              (awhen (intersect l1 l2)
                (when (not (equal it '(0 . 0)))
                  (in outer (collect it)))))))

(defun closest-intersection (p1 p2)
  (iter outer (for l1 in p1)
        (iter (for l2 in p2)
              (awhen (intersect l1 l2)
                (when (not (equal it '(0 . 0)))
                  (in outer (minimize (+ (abs (car it)) (abs (cdr it))))))))))

(defun answer-1 ()
  (with-open-file (f "input3")
    (let ((is1 (split "," (read-line f)))
          (is2 (split "," (read-line f))))
      (closest-intersection (path is1) (path is2)))))

(defun shortest-path (p1 p2)
  (intersections p1 p2))

(defun find-shortest-path (intersections p1 p2)
  (iter (for inter in intersections)
        (minimize (+ (steps-to inter p1) 
                     (steps-to inter p2)))))

(defun answer-2 ()
  (with-open-file (f "input3")
    (let* ((is1 (split "," (read-line f)))
           (is2 (split "," (read-line f)))
           (p1 (path is1))
           (p2 (path is2)))
      (find-shortest-path (intersections p1 p2) p1 p2))))
