(load "utilities.lisp")

(defun left (coord)
  (cons (1- (car coord)) (cdr coord)))

(defun right (coord)
  (cons (1+ (car coord)) (cdr coord)))

(defun up (coord)
  (cons (car coord) (1- (cdr coord))))

(defun down (coord)
  (cons (car coord) (1+ (cdr coord))))

(defun vertical-p (coord map)
  (let ((neighbours (gethash coord map)))
    (and (member (up coord) neighbours :test 'equal)
         (member (down coord) neighbours :test 'equal))))

(defun add-coordinate-to-map (coord track-type map)
  (labels ((right-turn-down ()
             (setf (gethash coord map) (list (left coord) (down coord)))
             (setf (gethash (left coord) map)
                   (adjoin coord (gethash (left coord) map) :test 'equal))
             (setf (gethash (down coord) map) 
                   (adjoin coord (gethash (down coord) map) :test 'equal)))
           (right-turn-up ()
             (setf (gethash coord map) (list (right coord) (up coord)))
             (setf (gethash (right coord) map)
                   (adjoin coord (gethash (right coord) map) :test 'equal))
             (setf (gethash (up coord) map) 
                   (adjoin coord (gethash (up coord) map) :test 'equal)))
           (left-turn-down ()
             (setf (gethash coord map) (list (down coord) (right coord)))
             (setf (gethash (down coord) map) 
                   (adjoin coord (gethash (down coord) map) :test 'equal))
             (setf (gethash (right coord) map) 
                   (adjoin coord (gethash (right coord) map) :test 'equal)))
           (left-turn-up ()
             (setf (gethash coord map) (list (up coord) (left coord)))
             (setf (gethash (up coord) map) 
                   (adjoin coord (gethash (up coord) map) :test 'equal))
             (setf (gethash (left coord) map) 
                   (adjoin coord (gethash (left coord) map) :test 'equal))))
    (case track-type
      (#\- (setf (gethash coord map) (list (left coord) (right coord)))
           (setf (gethash (left coord) map)
                 (adjoin coord (gethash (left coord) map) :test 'equal))
           (setf (gethash (right coord) map) 
                 (adjoin coord (gethash (right coord) map) :test 'equal)))
      (#\\ (if (and (gethash (up coord) map) 
                    (vertical-p (up coord) map)) 
               (right-turn-up)
               (right-turn-down)))
      (#\| (setf (gethash coord map) (list (up coord) (down coord)))
           (setf (gethash (up coord) map) (adjoin coord (gethash (up coord) map) :test 'equal))
           (setf (gethash (down coord) map) (adjoin coord (gethash (up coord) map) :test 'equal)))
      (#\/ (if (and (gethash (up coord) map)
                    (vertical-p (up coord) map))
               (left-turn-up)
               (left-turn-down)))
      (#\+ (setf (gethash coord map) (list (left coord) (right coord) (up coord) (down coord)))
           (setf (gethash (left coord) map)
                 (adjoin coord (gethash (left coord) map) :test 'equal))
           (setf (gethash (right coord) map)
                 (adjoin coord (gethash (right coord) map) :test 'equal))
           (setf (gethash (down coord) map)
                 (adjoin coord (gethash (down coord) map) :test 'equal))
           (setf (gethash (up coord) map)
                 (adjoin coord (gethash (up coord) map) :test 'equal))))))

(defun construct-map (lines)
  (let ((map (make-hash-table :test 'equal))
        (cart-positions (make-hash-table :test 'equal))
        carts)
    (loop for line in lines
       for y = 0 then (1+ y)
       do (loop for track-type across line
             for x = 0 then (1+ x)
             do (add-coordinate-to-map (cons x y) track-type map)
             when (or (char= track-type #\>)
                      (char= track-type #\<)
                      (char= track-type #\v)
                      (char= track-type #\^))
             do (push (cons track-type (cons 'left (cons x y))) carts)))
    (loop for cart in carts 
       do (setf (gethash (cddr cart) cart-positions) cart))
    (cons map (cons carts cart-positions))))

(defun read-input (filename)
  (construct-map (read-lines filename)))

(defun is-intersection (neighbours)
  (= (length neighbours) 4))

(defun turn-left (cart)
  (case (car cart)
    (#\^ (setf (car cart) #\<))
    (#\> (setf (car cart) #\^))
    (#\v (setf (car cart) #\>))
    (#\< (setf (car cart) #\v))))

(defun turn-right (cart)
  (case (car cart)
    (#\^ (setf (car cart) #\>))
    (#\> (setf (car cart) #\v))
    (#\v (setf (car cart) #\<))
    (#\< (setf (car cart) #\^))))

(defun turn-at-intersection (cart)
  (let ((intersection-choice (cadr cart)))
    (case intersection-choice
      (left (turn-left cart)
            (setf (cadr cart) 'straight))
      (straight (setf (cadr cart) 'right))
      (right (turn-right cart)
             (setf (cadr cart) 'left)))))

(defun can-go-straight (cart neighbours)
  (case (car cart)
    (#\> (member (right (cddr cart)) neighbours :test 'equal))
    (#\< (member (left (cddr cart)) neighbours :test 'equal))
    (#\^ (member (up (cddr cart)) neighbours :test 'equal))
    (#\v (member (down (cddr cart)) neighbours :test 'equal))))

(defun turn-with-one-choice (cart coord neighbours)
  (labels ((turn-horizontal ()
             (if (member (left coord) neighbours :test 'equal)
                 (setf (car cart) #\<)
                 (setf (car cart) #\>)))
           (turn-vertical ()
             (if (member (down coord) neighbours :test 'equal)
                 (setf (car cart) #\v)
                 (setf (car cart) #\^))))
    (case (car cart)
      (#\^ (turn-horizontal))
      (#\v (turn-horizontal))
      (#\> (turn-vertical))
      (#\< (turn-vertical)))))

(defun turn (cart coord neighbours)
  (if (is-intersection neighbours)
      (turn-at-intersection cart)
      (when (not (can-go-straight cart neighbours))
        (turn-with-one-choice cart coord neighbours))))

(defun update-position (cart)
  (case (car cart)
    (#\> (setf (cddr cart) (right (cddr cart))))
    (#\< (setf (cddr cart) (left (cddr cart))))
    (#\v (setf (cddr cart) (down (cddr cart))))
    (#\^ (setf (cddr cart) (up (cddr cart))))))

(defun move-minecart (cart map)
  (let ((neighbours (gethash (cddr cart) map)))
    (turn cart (cddr cart) neighbours)
    (update-position cart)))

(defun cons-compare (one other)
  (or (< (cdddr one) (cdddr other))
      (and (= (cdddr one) (cdddr other))
           (< (caddr one) (caddr other)))))

(defun move-carts (carts map)
  (let ((cart-positions (cdr carts)))
    (loop for cart-ordering = (sort (car carts) #'cons-compare) then (sort cart-ordering
                                                                           #'cons-compare)
       do (format t "CARTS ~a~%" cart-ordering)
       do (loop for cart in cart-ordering
             do (remhash (cddr cart) cart-positions)
               (move-minecart cart map)
               (when (gethash (cddr cart) cart-positions)
                 (format t "BOOOM! CRASH AT ~a~%" (cddr cart))
                 (return-from move-carts (cddr cart)))
               (setf (gethash (cddr cart) cart-positions) cart)))))

(defparameter *input-filename* "minecart-madness-input.txt")
(defparameter *test-input-filename* "minecart-madness-test-input.txt")
(defparameter *test-input2-filename* "minecart-madness-test-input2.txt")

(defun test ()
  (destructuring-bind (map . carts) (read-input *test-input-filename*)
    (print-hash-table map)
    (move-carts carts map)))

(defun solution-part-1 ()
  (destructuring-bind (map . carts) (read-input *input-filename*)
    (format t "CARTS ~a~%" carts)
    (move-carts carts map)))

(defun move-carts-and-remove-crashes (carts map)
  (let ((cart-positions (cdr carts)))
    (loop for cart-ordering = (sort (car carts) #'cons-compare) 
       then (sort cart-ordering #'cons-compare)
;;       do (format t "CARTS ~a~%" cart-ordering)
       do (loop for remaining = cart-ordering then (cdr remaining)
             while remaining
             do (let ((cart (car remaining)))
                  (remhash (cddr cart) cart-positions)
                  (move-minecart cart map)
                  (if (gethash (cddr cart) cart-positions)
                      (progn 
;;                        (format t "DESTROYING ~a ~a~%" cart (gethash (cddr cart) cart-positions))
                        (setf cart-ordering (delete 
                                             (gethash (cddr cart) cart-positions) cart-ordering))
                        (setf remaining (delete (gethash (cddr cart) cart-positions) remaining))
                        (setf cart-ordering (delete cart cart-ordering))
                        (remhash (cddr cart) cart-positions))
                      (setf (gethash (cddr cart) cart-positions) cart))))
       when (= (hash-table-count cart-positions) 1)
       do (return-from move-carts-and-remove-crashes cart-ordering))))

(defun test-2 ()
  (destructuring-bind (map . carts) (read-input *test-input2-filename*)
    (move-carts-and-remove-crashes carts map)))

(defun solution-part-2 ()
  (destructuring-bind (map . carts) (read-input *input-filename*)
    (move-carts-and-remove-crashes carts map)))
