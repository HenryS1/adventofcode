(defun move (direction position)
  (case direction
    (N (cons (+ (car position) 1) (cdr position)))
    (S (cons (- (car position) 1) (cdr position)))
    (E (cons (car position) (+ (cdr position) 1)))
    (W (cons (car position) (- (cdr position) 1)))))

(defun counter-clockwise (direction)
  (case direction
    (N 'W)
    (S 'E)
    (E 'N)
    (W 'S)))

(defun make-a-circuit (direction steps-left side-width position callback)
  (let ((new-position (move direction position)))
    (funcall callback position)
    (cond 
      ((> steps-left 0)
       (make-a-circuit direction 
                       (- steps-left 1) side-width new-position callback))
      ((and (= steps-left 0) 
            (equal direction 'E))
       (let ((new-side-width (+ side-width 2)))
         (make-a-circuit 'N (- new-side-width 3)
                         new-side-width new-position callback)))
      ((and (= steps-left 0)
            (equal direction 'S))
       (make-a-circuit 'E (- side-width 1) side-width new-position callback))
      (t (make-a-circuit (counter-clockwise direction) (- side-width 2)
                         side-width new-position callback)))))

(defun get-value (position square-values)
  (or (gethash position square-values) 0))

(defun sum-adjacent-values (square-values position)
  (+ (get-value position square-values)
     (get-value (move 'E position) square-values)
     (get-value (move 'N (move 'E position)) square-values)
     (get-value (move 'N position) square-values)
     (get-value (move 'W (move 'N position)) square-values)
     (get-value (move 'W position) square-values)
     (get-value (move 'S (move 'W position)) square-values)
     (get-value (move 'S position) square-values)
     (get-value (move 'E (move 'S position)) square-values)))

(defun loop-until-tile (tile)
  (let ((current 1))
    (make-a-circuit 'E 0 1 '(0 . 0) 
                    (lambda (position)
                      (if (= current tile)
                          (return-from loop-until-tile (+ (abs (car position))
                                                          (abs (cdr position))))
                          (incf current))))))

(defun loop-until-tile-value-is-greater (value)
  (let ((current 1)
        (square-values (make-hash-table :test 'equal)))
    (setf (gethash '(0 . 0) square-values) 1)
    (make-a-circuit 'E 0 1 '(0 . 0)
                    (lambda (position)
                      (let ((adjacent-sum (sum-adjacent-values square-values position)))
                        (setf (gethash position square-values) adjacent-sum)
                        (setf current adjacent-sum)
                        (if (> current value)
                          (return-from loop-until-tile-value-is-greater current)))))))

(defun solution-to-part-1 ()
  (loop-until-tile 277678))

(defun solution-to-part-2 ()
  (loop-until-tile-value-is-greater 277678))
