(eval-when (:load-toplevel :compile-toplevel)
  (ql:quickload :cl-arrows)
  (ql:quickload :cl-ppcre)
  (ql:quickload :iterate)
  (ql:quickload :anaphora)
  (ql:quickload :alexandria)
  (ql:quickload :trivia)
  (ql:quickload :trivia.ppcre)
  (ql:quickload :metabang-bind)
  (ql:quickload :rove)
  (load "../2018/queue.lisp")
  (load "../2018/priority-queue.lisp"))

(defpackage :day24
  (:use :cl :cl-ppcre :cl-arrows :iterate :bind :anaphora :alexandria :trivia :trivia.ppcre :rove))

(in-package :day24)

(defun find-locations (mp)
  (iter outer
        (for r from 0)
        (for line in-vector mp)
        (iter (for c from 0)
              (for ch in-string line)
              (awhen (digit-char-p ch)
                (in outer (collect (cons it (cons r c))))))))

(defun find-distances (locations mp)
  (let ((distances (make-hash-table))) 
    (labels ((neighbours (r c seen)
               (remove-if-not (lambda (coord)
                                (and (not (gethash coord seen))
                                     (bind (((row . col) coord))
                                       (and (<= 0 row (- (length mp) 1))
                                            (<= 0 col (- (length (aref mp 0)) 1))
                                            (let ((ch (aref (aref mp row) col)))
                                              (or (char= ch #\.) (digit-char-p ch)))))))
                              (vector (cons r (+ c 1)) (cons r (- c 1)) 
                                      (cons (+ r 1) c) (cons (- r 1) c))))
             (bfs (num coord seen)
               (iter (with q = (make-queue (cons 0 coord)))
                     (while (non-empty q))
                     (for (dist . (r . c)) = (poll q))
                     (setf (gethash (cons r c) seen) t)
                     (for ch = (aref (aref mp r) c))
                     (if (or (equal (cons r c) coord) (char= ch #\.))
                         (iter (for nbr in-vector (neighbours r c seen))
                               (setf (gethash nbr seen) t)
                               (enqueue (cons (+ dist 1) nbr) q))
                         (push (cons (digit-char-p ch) dist) (gethash num distances))))))
      (iter (for (num . coord) in locations)
            (bfs num coord (make-hash-table :test 'equal)))
      distances)))

(defun read-map ()
  (iter (for line in-file "input24" :using #'read-line)
        (collect line result-type 'vector)))

(defun encode-dist (pair)
  (+ (ash (cdr pair) 3) (car pair)))

(defun decode-bits (bits)
  (values (ash bits -3) (logand bits 7)))

(defun bittify (distances)
  (iter (with bitted = (make-hash-table))
        (for (n dists) in-hashtable distances)
        (for new-dist = (make-array (length dists) :element-type 'fixnum 
                                    :initial-contents (mapcar #'encode-dist dists)))
        (setf (gethash n bitted) new-dist)
        (finally (return bitted))))

(defconstant state-mask (- (ash 1 11) 1))
(defconstant seen-mask (- (ash 1 8) 1))
(defconstant inf (- (expt 2 32) 1))

(declaim (inline get-seen with-dist get-position get-dist 
                 get-state dist-comp make-state all-visited))
(defun get-seen (state) (logand state seen-mask))
(defun with-dist (state dist) (logior state (ash dist 11)))
(defun get-position (state) (ash state -8))
(defun get-dist (state-dist) (ash state-dist -11))
(defun get-state (state-dist) (logand state-dist state-mask))
(defun dist-comp (a b) (< (get-dist a) (get-dist b)))
(defun make-state (position seen) (logior (logior seen (ash 1 position)) (ash position 8)))
(defun all-visited (state) (= (get-seen state) seen-mask))

(defun explore (distances &optional (return-to-start nil))
  (iter (with q = (make-pq #'dist-comp (with-dist 1 0)))
        (with dist-to = (make-hash-table))
        (while (pq-nonempty q))
        (for state-dist = (pop-pq q))
        (for state = (get-state state-dist))
        (when (all-visited state)
          (if (or (not return-to-start) (= (get-position state) 0)) 
              (return (get-dist state-dist))
              (progn (setf state (logxor state 1)))))
        (for position = (get-position state))
        (iter (for nbr in-vector (gethash position distances))
              (bind (((:values sep loc) (decode-bits nbr))
                     (new-state (make-state loc (get-seen state)))
                     (new-dist (+ sep (get-dist state-dist))))
                (when (< new-dist (gethash new-state dist-to inf))
                  (setf (gethash new-state dist-to) new-dist)
                  (insert-pq (with-dist new-state new-dist) q))))))


(defun solve (mp &optional (return-to-start nil))
  (let ((distances (-<> (find-locations mp) (find-distances <> mp) (bittify <>))))
    (explore distances return-to-start)))

(defun answer1 ()
  (solve (read-map)))

(defun answer2 ()
  (solve (read-map) t))

(run-suite *package*)
