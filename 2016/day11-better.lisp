(eval-when (:compile-toplevel :load-toplevel)
  (load "../2018/priority-queue.lisp")
  (ql:quickload :iterate)
  (ql:quickload :alexandria)
  (ql:quickload :metabang-bind))

(defpackage :day11
  (:use :cl :iterate :alexandria :bind))

(in-package :day11)

(defun safe-floor (ms gs)
  (or (= (logand ms gs) ms)
      (= gs 0)))

(defun get-floor (floors n num-ms)
  (logand (ash floors (- (* (max 0 n) (* num-ms 2)))) 
          (- (ash 1 (* 2 num-ms)) 1)))

(defun ms-and-gs (floor num-ms)
  (values (logand (ash floor (- num-ms)) (- (ash 1 num-ms) 1))
          (logand floor (- (ash 1 num-ms) 1))))

(defun count-bits (i)
  (iter (while (> i 0))
        (count (oddp i))
        (setf i (ash i -1))))

(defun priority (moves-so-far floors)
  (+ moves-so-far 
     (iter (for i from 0 to (- (length floors) 1))
           (for equipment = (get-floor floors i))
           (for equipment-count = (+ (count-bits (aref equipment 0))
                                     (count-bits (aref equipment 1))))
           (summing (+ (* (- 3 i) 2 (- equipment-count 2)) (- 3 i))))))

(defun finished (target)
  (lambda (floors)
    (let ((floor-4 (aref floors 3)))
      (= (+ (aref floor-4 0) (aref floor-4 1)) target))))

(defun toggle-m (floors m num-ms)
  (logxor floors))

(defun enqueue-next-states (seen moves-so-far elevator floors direction num-ms pq)
  ;; (format t "MOVES SO FAR ~a~%" moves-so-far)
  ;; (format t "ELEVATOR ~a~%" elevator)
  ;; (format t "DIRECTION ~a~%" direction)
  (bind (((:values ms gs) (ms-and-gs (get-floor floors elevator num-ms) num-ms))
         ((:values mso gso) (ms-and-gs (get-floor floors (+ elevator direction) num-ms))))
    ;; (format t "MS ~a GS ~a MSO ~a GSO ~a~%" ms gs mso gso)
    (iter (for i from 0 to (- num-ms 1))
          (when (and 
                 (or (= gso 0)
                     (> (logand (ash 1 i) gso) 0))
                 (> (logand (ash 1 i) ms) 0))
            (let ((new-state floors))
              (setf new-state (logxor new-state (ash 1 (+ i (* elevator num-ms)))))
              (setf new-state (logxor new-state (ash 1 (+ i (* (+ elevator direction) num-ms)))))
              ;; (format t "INSERT STATE -1 ~a~%" new-state)
              (when (not (gethash new-state seen))
                (setf (gethash new-state seen) t)
                (insert-pq (list (priority moves-so-far new-state) (+ moves-so-far 1)
                                 (+ elevator direction) new-state) pq)))))
    (iter (for i from 0 to (- num-ms 1))
          (when (and 
                 (= mso gso)
                 (> (logand (ash 1 i) gs) 0)
                 (or (= gs (ash 1 i))
                     (= (logxor gs (ash 1 i)) ms)))
            (let ((new-state floors))
              (setf new-state (logxor gs (ash 1 (+ i (* elevator))))
                    (aref (aref new-state (+ elevator direction)) 1)
                    (logxor gso (ash 1 i)))
              ;; (format t "INSERT STATE 0~%")
              (insert-pq (list (priority moves-so-far new-state) (+ moves-so-far 1) 
                               (+ elevator direction) new-state) pq))))
    (iter (for i from 0 to (- num-ms 1))
          (when (and 
                 (> (logand (ash 1 i) ms) 0)
                 (> (logand (ash 1 i) gs) 0)
                 (or (= gso mso)
                     (= mso 0)))
            (let ((new-state (map 'vector #'copy-seq floors)))
              (setf (aref (aref new-state elevator) 0)
                    (logxor ms (ash 1 i))
                    (aref (aref new-state (+ elevator direction)) 0)
                    (logxor mso (ash 1 i))
                    (aref (aref new-state elevator) 1)
                    (logxor gs (ash 1 i))
                    (aref (aref new-state (+ elevator direction)) 1)
                    (logxor gso (ash 1 i)))
              ;; (format t "INSERT STATE~%")
              (insert-pq (list (priority moves-so-far new-state) (+ moves-so-far 1)
                               (+ elevator direction) new-state) pq))))))

(defparameter *floors-part-1* #(#(1 1) #(0 30) #(30 0) #(0 0)))

(defun comp-states (one other)
  (< (car one) (car other)))

(defun find-path (floors)
  (let* ((pq (make-pq #'comp-states))
         (target (iter (for f in-vector floors) (sum (+ (aref f 0) (aref f 1)))))
         (finishedp (finished target))
         (num-ms (count-bits (floor target 2))))
    (insert-pq (list (priority 0 floors) 0 0 floors) pq)
    (iter (for (priority moves-so-far elevator state) = (pop-pq pq))
          ;; (format t "STATE ~a~%" state)
          (while (not (funcall finishedp state)))
          (iter (for direction in '(1 -1))
                (when (<= 0 (+ elevator direction) 3)
                  (enqueue-next-states moves-so-far elevator state direction num-ms pq)))
          (finally (return (cons moves-so-far state))))))
