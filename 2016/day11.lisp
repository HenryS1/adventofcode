(eval-when (:compile-toplevel :load-toplevel)
  (ql:quickload :iterate)
  (ql:quickload :cl-arrows)
  (load "../2018/queue.lisp"))

(defpackage :day11
  (:use :cl :iterate :cl-arrows))

(in-package :day11)

(defun make-generator-mask (num-chips)
  (iter (with res = 0)
        (for i from 0 to (- num-chips 1))
        (setf res (+ (ash res 2) 1))
        (finally (return res))))

(defun make-chip-mask (num-chips)
  (iter (with res = 0)
        (for i from 0 to (- num-chips 1))
        (setf res (+ (ash res 2) 2))
        (finally (return res))))

(declaim (inline subtract-rightmost-bit rightmost-bit 
                 safe-floor get-elevator get-floor set-floor
                 set-elevator))

(defun safe-floor (floor generator-mask chip-mask)
  (declare (optimize (speed 3))
           (fixnum floor generator-mask chip-mask))
  (or (= (logand chip-mask floor) 0)
      (= (logand generator-mask floor) 0)
      (= (logand (logand (ash floor -1) floor) generator-mask) (ash (logand floor chip-mask) -1))))

(defun get-elevator (state)
  (declare (optimize (speed 3))
           (fixnum state))
  (ash state -60))

(defun get-floor (state floor-num num-chips)
  (declare (optimize (speed 3)))
  (ash (logand (- (ash 1 (* (+ floor-num 1) num-chips 2)) 1) state)
       (- (* floor-num num-chips 2))))

(defun set-floor (state floor-num num-chips new-floor)
  (declare (optimize (speed 3)))
  (logior (logxor state (ash (get-floor state floor-num num-chips) (* floor-num num-chips 2))) 
          (ash new-floor (* floor-num num-chips 2))))

(defun rightmost-bit (n) (logand n (- n)))
(defun subtract-rightmost-bit (n) (- n (rightmost-bit n)))

(defun choose-one-or-two (flr callback)
  (iter outer
        (for initial first flr then (subtract-rightmost-bit initial))
        (while (> initial 0))
        (iter (for rest first (subtract-rightmost-bit initial)
                   then (subtract-rightmost-bit rest))
              (funcall callback (logior (rightmost-bit initial) (rightmost-bit rest)))
              (until (= rest 0)))))

(defun set-elevator (current-elevator next-elevator state)
  (logxor (ash next-elevator 60) (logxor (ash current-elevator 60) state)))

(defun make-state-masks (num-chips num-floors)
  (declare (optimize (speed 3)))
  (let ((arr (make-array num-chips :element-type 'fixnum)))
    (declare ((simple-array fixnum) arr))
    (iter (for i from 0 to (- num-chips 1))
          (setf (aref arr i) 
                (iter (with initial = (ash 3 (* i 2)))
                      (for j from 0 to (- num-floors 1))
                      (for res first initial then (logior res (ash initial (* j num-chips 2))))
                      (finally (return res)))))
    arr))

(defun state-hash (st masks)
  (declare (optimize (speed 3)))
  (labels ((swap (i j)
             (let ((one (logand st (aref masks i)))
                   (other (logand st (aref masks j))))
               (setf st (logxor st one other (ash one (* 2 (- j i))) (ash other (* 2 (- i j))))))))
     (iter (with len = (length masks))
           (for i from 0 to (- len 2))
           (iter (with mx-ind = i)
                 (with mx = 0)
                 (for j from i to (- len 1))
                 (for curr = (ash (logand (aref masks j) st) (- (* j 2))))
                 (when (> curr mx)
                   (setf mx curr 
                         mx-ind j))
                 (finally (swap i mx-ind))))
    st))

(defun enqueue-nbrs (state masks num-moves
                     q chip-mask generator-mask seen num-chips)
  (declare (optimize (speed 3)))
  (let* ((elevator (get-elevator state))
         (flr (get-floor state elevator num-chips))
         (up (get-floor state (+ elevator 1) num-chips))
         (down (get-floor state (- elevator 1) num-chips)))
    (labels ((next-state (new-flr new-nbr direction)
               (-<> (set-floor state elevator num-chips new-flr)
                    (set-floor <> (+ elevator direction) num-chips new-nbr)
                    (set-elevator elevator (+ elevator direction) <>))))
      (choose-one-or-two flr (lambda (choice) 
                               (let ((new-flr (logxor flr choice))
                                     (new-up (logxor up choice))
                                     (new-down (logxor down choice)))
                                 (when (safe-floor new-flr generator-mask chip-mask)
                                   (when (and (< (+ elevator 1) 4)
                                              (safe-floor new-up generator-mask chip-mask))
                                     (let* ((next-up (next-state new-flr new-up 1))
                                            (hsh (state-hash next-up masks)))
                                       (when (not (gethash hsh seen))
                                         (let ((new-entry (make-array 2 :element-type '(unsigned-byte 64))))
                                           (declare ((simple-array (unsigned-byte 64)) new-entry))
                                           (setf (gethash hsh seen) t)
                                           (setf (aref new-entry 0) (+ num-moves 1))
                                           (setf (aref new-entry 1) next-up)
                                           (enqueue new-entry q)))))
                                   (when (and (>= (- elevator 1) 0)
                                              (safe-floor new-down generator-mask chip-mask))
                                     (let* ((next-down (next-state new-flr new-down -1))
                                            (hsh (state-hash next-down masks)))
                                       (when (not (gethash hsh seen))
                                           (let ((new-entry (make-array 2 :element-type '(unsigned-byte 64))))
                                           (declare ((simple-array (unsigned-byte 64)) new-entry))
                                           (setf (gethash hsh seen) t)
                                           (setf (aref new-entry 0) (+ num-moves 1))
                                           (setf (aref new-entry 1) next-down)
                                           (enqueue new-entry q))))))))))))

(defun explore (start-state num-chips num-floors target)
  (declare (optimize (speed 3)))
  (let* ((seen (make-hash-table))
         (start (make-array 2 :element-type 'fixnum :initial-contents (list 0 start-state)))
         (generator-mask (make-generator-mask num-chips))
         (chip-mask (make-chip-mask num-chips))
         (masks (make-state-masks num-chips num-floors))
         (q (make-queue start)))
    (iter (while (non-empty q))
          (for curr = (poll q))
          (for num-moves = (aref curr 0))
          (for state = (aref curr 1))
          (when (= state target)
            (leave (cons state num-moves)))
          (enqueue-nbrs state masks num-moves q chip-mask generator-mask seen 
                              num-chips))))

(defun part-one ()
  (let ((start-state #b1010101000010101011100000000)
        (num-chips 5)
        (target #b11000000000000000000001111111111000000000000000000000000000000))
    (explore start-state num-chips 4 target)))

(defun part-two ()
  (let ((start-state #b101010100000000101010111111100000000)
        (num-chips 7)
        (target #b0011000011111111111111000000000000000000000000000000000000000000))
    (explore start-state num-chips 4 target)))
