(defun count-bits (n)
  (loop while (> n 0)
     when (oddp n)
     count n
     do (setf n (ash n -1))))

(defparameter *input* 1350)

(defun openp (x y)
  (let ((n (+ (* x x) (* 3 x) (* 2 x y) y (* y y) *input*)))
    (evenp (count-bits n))))

(defun neighbours (start-x start-y)
  (loop with nbrs = (list)
     for x from (- start-x 1) to (+ start-x 1)
     do (loop for y from (- start-y 1) to (+ start-y 1)
           when (and (or (/= x start-x) (/= y start-y))
                     (openp x y))
           do (push (cons x y) nbrs))))

(defun find-path (destination)
  (let* ((q (list (cons 0 0)))
         (next q)
         (steps-to (make-hash-table :test 'equal))
         (visited (make-hash-table :test 'equal)))
    (labels ((enqueue (el)
               (setf q (append q (list el)))
               (setf q (cdr q)))
             (dequeue ()
               (if (null next) 
                   nil
                   (let ((result (car next)))
                     (setf next (cdr next))
                     result)))
             (bfs ()
               (when next
                 (destructuring-bind (x . y) (dequeue)
                   (loop for neighbour in (neighbours x y)
                      for steps-to-current = (gethash (cons x y) steps-to)
                      when (not (gethash neighbour visited))
                      do (setf (gethash neighbour steps-to) 
                               (+ steps-to-current 1))
                        (setf (gethash neighbour visited) t)
                      until (equal neighbour destination)
                      do (enqueue neighbour)))
                 (bfs))))
      (bfs)
      (gethash destination steps-to))))
