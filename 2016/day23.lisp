(eval-when (:load-toplevel :compile-toplevel)
  (ql:quickload :cl-ppcre)
  (ql:quickload :iterate)
  (ql:quickload :anaphora)
  (ql:quickload :alexandria)
  (ql:quickload :trivia)
  (ql:quickload :trivia.ppcre)
  (ql:quickload :rove))

(defpackage :day23
  (:use :cl :cl-ppcre :iterate :anaphora :alexandria :trivia :trivia.ppcre :rove))

(in-package :day23)

(defun ints (line) 
  (mapcar #'parse-integer (all-matches-as-strings "-?\\d+" line)))

(defun toggle (instructions index offset)
  (let ((i (+ index offset)))
    (when (<= 0 i (- (length instructions) 1))
      (setf (aref instructions i)
            (match (aref instructions i)
              ((list 'jnz a b)
               (list 'cpy a b))
              ((list _ a b)
               (list 'jnz a b))
              ((list 'inc a)
               (list 'dec a))
              ((list _ a)
               (list 'inc a)))))))

(defun interpret (index instructions env)
  (labels ((value (i)
             (gethash i env i))) 
    (match (aref instructions index)
      ((list 'cpy x y)
       (when (symbolp y)
         (setf (gethash y env) (value x)))
       1)
      ((list 'inc a)
       (when (symbolp a)
         (incf (gethash a env)))
       1)
      ((list 'dec a)
       (when (symbolp a)
         (decf (gethash a env)))
       1)
      ((list 'jnz a i)
       (if (/= (value a) 0) 
           (value i)
           1))
      ((list 'tgl x)
       (toggle instructions index (value x))
       1))))

(defun interpret-instructions (instructions env)
  (iter (for index first 0 then (+ index (interpret index instructions env)))
        (while (<= 0 index (- (length instructions) 1)))
        (finally (return (gethash 'a env)))))

(defun syms (line)
  (let (*read-eval*)
    (with-input-from-string (s line)
      (iter (for sym in-stream s) (collect sym)))))

(defun read-instructions (file)
  (let (*read-eval*)
    (map 'vector #'identity 
         (iter (for line in-file file :using #'read-line) 
               (collect (syms line))))))

(deftest toggle-test 
  (let ((instructions #((cpy x y) (inc a) (dec a) (jnz a i) (tgl x))))
    (ok (equal (toggle instructions 0 0) '(jnz x y)))
    (ok (equal (toggle instructions 1 0) '(dec a)))
    (ok (equal (toggle instructions 2 0) '(inc a)))
    (ok (equal (toggle instructions 3 0) '(cpy a i)))
    (ok (equal (toggle instructions 4 0) '(inc x)))))

(deftest interpret-test 
  (let ((instructions #((cpy a b) (inc a) (dec a) (jnz a b) (tgl -1)))
        (env (make-hash-table)))
    (setf (gethash 'a env) 3 (gethash 'b env) 0 (gethash 'c env) 0 (gethash 'd env) 0)
    (ok (= (interpret 0 instructions env) 1))
    (ok (= (gethash 'b env 3)))
    (ok (= (interpret 1 instructions env) 1))
    (ok (= (gethash 'a env) 4))
    (ok (= (interpret 2 instructions env) 1))
    (ok (= (gethash 'a env) 3))
    (ok (= (interpret 3 instructions env) 3))
    (ok (= (interpret 4 instructions env) 1))
    (ok (equal (aref instructions 3) '(cpy a b)))))

(defun answer1 ()
  (let ((env (make-hash-table)))
    (setf (gethash 'a env) 7 (gethash 'b env) 0 (gethash 'c env) 0 (gethash 'd env) 0)
    (interpret-instructions (read-instructions "input23") env)))

(defun answer2 ()
  (labels ((fact (n) (if (= n 0) 1 (* n (fact (- n 1))))))
    (+ (fact 12) (* 77 72))))

(run-suite *package*)
