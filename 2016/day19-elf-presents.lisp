(defun make-circular-list (l)
  (setf (cdr (last l)) l)
  l)

(defun initialise-presents (n)
  (make-circular-list (loop for i from 1 to n collect (cons 1 i))))

(defun distribute-presents (n)
  (loop for current = (initialise-presents n) then (cdr current)
     until (eq current (cdr current))
     do (incf (caar current) (caadr current))
       (setf (cdr current) (cddr current))
     finally (return (cdar current))))

(defun find-right-of-directly-opposite (n l)
  (loop for i from 1 to (floor n 2)
     for current = l then (cdr current) finally (return current)))

(defun distribute-opposite-presents (n)
  (loop with one = (initialise-presents n)
     with right-of-opposite = (find-right-of-directly-opposite n one)
     for opposite = (cdr right-of-opposite)
     until (eq one (cdr one))
     do (incf (caar one) (caar opposite))
       (setf (cdr right-of-opposite) (cddr right-of-opposite))
     when (oddp n)
     do (setf right-of-opposite (cdr right-of-opposite))
     do (decf n)
       (setf one (cdr one))
     finally (return (cdar one))))

(defun answer1 ()
  (distribute-presents 3004953))

(defun answer2 ()
  (distribute-opposite-presents 3004953))
