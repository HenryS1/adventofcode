(ql:quickload :cl-ppcre)
(ql:quickload :iterate)
(ql:quickload :trivia)

(defpackage :day21
  (:use :cl :cl-ppcre :iterate :trivia))

(in-package :day21)

(defun swap-x-y (str x y)
  (rotatef (char str x) (char str y))
  str)

(defun swap-letters (str a b)
  (let ((a-pos (position a str))
        (b-pos (position b str)))
    (swap-x-y str a-pos b-pos)))

(defun rotate-left (str steps)
  (setf steps (mod steps (length str)))
  (concatenate 'string (subseq str steps) (subseq str 0 steps)))

(defun rotate-right (str steps)
  (setf steps (mod steps (length str)))
  (concatenate 'string (subseq str (- (length str) steps))
               (subseq str 0 (- (length str) steps))))

(defun rotate-on-letter (str a)
  (let ((a-pos (position a str)))
    (rotate-right str (+ 1 (if (>= a-pos 4) (+ a-pos 1) a-pos)))))

; y = mod(x + (1 + (x > 4) + x), len s)
;   = mod(2x + 1 + (x > 4), len s) = 2x + 1 + (x > 4) || 2x + 1 + (x > 4) - (len s)
; x = (y - 1 - ((y-2) / 2 > 4) / 2 || (y + len s - 1 - ((y + len s - 2) / 2 > 4) / 2
(defun reverse-rotate-on-letter (str a)
  (let* ((y (position a str))
         (x1 (floor (- y 1 (if (> (floor (- y 2) 2) 4) 1 0)) 2))
         (x2 (floor (- (+ y (length str)) 1 
                       (if (> (floor (- (+ y (length str)) 2) 2) 4)
                           1 0)) 2))
         (one (if (< x1 y) (rotate-left str (- y x1)) (rotate-right str (- x1 y))))
         (other (if (< x2 y) (rotate-left str (- y x2)) (rotate-right str (- x2 y)))))
    (if (string= (rotate-on-letter one a) str) one other)))

(defun reverse-positions (str x y)
  (concatenate 'string (subseq str 0 x) 
               (reverse (subseq str x (+ y 1)))
               (subseq str (+ y 1))))

(defun move (str x y)
  (cond ((= x y)
         str)
        ((< y x)
         (concatenate 'string (subseq str 0 y)
                      (subseq str x (+ x 1))
                      (subseq str y x)
                      (subseq str (+ x 1))))
        (t (concatenate 'string (subseq str 0 x)
                        (subseq str (+ x 1) (+ y 1)) 
                        (subseq str x (+ x 1))
                        (subseq str (+ y 1))))))

(defun sym-letter (a)
  (char-downcase (aref (symbol-name a) 0)))

(defun answer-1 ()
  (let (*read-eval*)
    (iter (with input = "abcdefgh")
          (for line in-file "input21" using #'read-line)
          (match (mapcar #'read-from-string (split "\\s+" line))
            ((list* 'swap 'position x 'with 'position y _)
             (setf input (swap-x-y input x y)))
            ((list* 'swap 'letter a 'with 'letter b _)
             (setf input (swap-letters input (sym-letter a) (sym-letter b))))
            ((list* 'rotate 'right n _)
             (setf input (rotate-right input n)))
            ((list* 'rotate 'left n _)
             (setf input (rotate-left input n)))
            ((list* 'rotate 'based 'on 'position 'of 'letter a _)
             (setf input (rotate-on-letter input (sym-letter a))))
            ((list* 'reverse 'positions x 'through y _)
             (setf input (reverse-positions input x y)))
            ((list* 'move 'position x 'to 'position y _)
             (setf input (move input x y))))
          (finally (return input)))))

(defun answer-2 ()
  (let (*read-eval*)
    (let ((lines (reverse (iter (for line in-file "input21" using #'read-line)
                                (collect line)))))
      (iter (with input = "fbgdceah")
            (for line in lines)
            (match (mapcar #'read-from-string (split "\\s+" line))
              ((list* 'swap 'position x 'with 'position y _)
               (setf input (swap-x-y input x y)))
              ((list* 'swap 'letter a 'with 'letter b _)
               (setf input (swap-letters input (sym-letter a) (sym-letter b))))
              ((list* 'rotate 'right n _)
               (setf input (rotate-left input n)))
              ((list* 'rotate 'left n _)
               (setf input (rotate-right input n)))
              ((list* 'rotate 'based 'on 'position 'of 'letter a _)
               (setf input (reverse-rotate-on-letter input (sym-letter a))))
              ((list* 'reverse 'positions x 'through y _)
               (setf input (reverse-positions input x y)))
              ((list* 'move 'position x 'to 'position y _)
               (setf input (move input y x))))
            (finally (return input))))))
