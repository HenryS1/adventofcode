(eval-when (:compile-toplevel :load-toplevel)
  (ql:quickload :trivia)
  (ql:quickload :trivia.ppcre)
  (ql:quickload :cl-ppcre)
  (ql:quickload :iterate)
  (ql:quickload :anaphora)
  (ql:quickload :metabang-bind)
  (ql:quickload :alexandria)
  (ql:quickload :cl-arrows)
  (load "../2018/queue.lisp")
  (load "../2018/priority-queue.lisp"))

(defpackage :day18
  (:use :cl :cl-ppcre :cl-arrows :trivia :trivia.ppcre
        :iterate :alexandria :anaphora :metabang-bind))

(in-package :day18)

(defun ints (line)
  (mapcar #'parse-integer (all-matches-as-strings "-?\\d+" line)))

(defun read-syms (line &optional (sep " "))
  (let (*read-eval*)
    (mapcar #'read-from-string (split sep line))))

(defun read-lines ()
  (iter (for line in-file "input18" using #'read-line)
        (collect line)))

(defun read-exp (str)
  (map 'list #'identity (remove-if (lambda (c) (char= c #\space)) str)))

(defun eval-next-exp (rest)
  (if (digit-char-p (car rest))
      (cons (digit-char-p (car rest)) (cdr rest))
      (process-exp (cdr rest))))

(defun process-exp (exp)
  (labels ((rec (op total rest)
             (if (null rest)
                 (cons total nil)
                 (case (car rest)
                   (#\) (cons total (cdr rest)))
                   (#\+ (rec #'+ total (cdr rest)))
                   (#\* (rec #'* total (cdr rest)))
                   (otherwise (destructuring-bind (v . tail) (eval-next-exp rest)
                                (if op
                                    (rec nil (funcall op total v) tail)
                                    (rec nil v tail))))))))
    (rec nil 0 exp)))

(defun next-exp (exp)
  (labels ((rec (rest)
             (cond ((null rest) nil)
                   ((atom rest)
                    (list rest))
                   ((char= (car rest) #\()
                    (iter (for (sub-exp . rem) first (next-exp (cdr rest))
                               then (next-exp rem))
                          (when (char= (car rem) #\))
                            (appending sub-exp into sub-exps)
                            (collect #\) into sub-exps))
                          (while (char/= (car rem) #\)))
                          (appending sub-exp into sub-exps)
                          (finally (return (cons (cons #\( sub-exps) (cdr rem))))))
                   (t (cons (list (car rest)) (cdr rest))))))
    (rec exp)))

(defun bracket-sub-expressions (exp)
  (cond ((null exp) exp)
        ((char= (car exp) #\()
         (append (list #\() (bracket-exp (butlast (cdr exp))) (list #\))))
        (t exp)))

(defun bracket-exp (exp)
  (iter (with (fst . fst-rest) = (next-exp exp))
        (for (op . op-rest) first (next-exp fst-rest) then (next-exp lst-rest))
        (for (lst . lst-rest) = (next-exp op-rest))       
        (for lst-bracketed = (bracket-sub-expressions lst))
        (for fst-bracketed first (bracket-sub-expressions fst) then latest)
        (when (char= (car op) #\*)
          (progn (appending fst-bracketed)
                 (appending op)))
        (when (not lst-rest)
          (when (char= (car op) #\+)
            (collect #\()
            (appending fst-bracketed)
            (appending op))
          (appending lst-bracketed)
          (when (char= (car op) #\+)
            (collect #\))))
        (for latest = (if (char= (car op) #\+)
                          (append (list #\() fst-bracketed op lst-bracketed (list #\)))
                          lst-bracketed))
        (while lst-rest)))

(defun part-1 ()
  (reduce #'+ (mapcar (lambda (exp) (car (process-exp exp))) (mapcar #'read-exp (read-lines)))))

(defun part-2 ()
  (reduce #'+ (mapcar (lambda (exp) (car (process-exp (bracket-exp exp))))
                      (mapcar #'read-exp (read-lines)))))
