(defpackage :day18
  (:use 
   :cl 
   :iterate 
   :alexandria 
   :queue
   :fixnum-pq
   :anaphora 
   :metabang-bind)
  (:export 
   :calibration-value
   :total-calibration-value
   :digits-in-line
   :all-calibration-values))

(in-package :day18)

(defun ints (line) 
  (mapcar #'parse-integer (cl-ppcre:all-matches-as-strings "-?\\d+" line)))

(defconstant init-rows 71)
(defconstant init-columns 71)

(defstruct memory (rows init-rows :type fixnum) (columns init-columns :type fixnum) 
           (locations (make-array (* init-rows init-columns)
                                  :element-type 'bit) :type (simple-array bit)))

(defun read-input (file)
  (with-open-file (f file)
    (loop for line = (read-line f nil nil)
          while line collect (ints line))))

(declaim (inline let-bytes-fall))
(defun let-bytes-fall (byte-locations memory n)
  (let ((columns (memory-columns memory))
        (locations (memory-locations memory)))
    (loop for (row column) in byte-locations
          for i from 1 to n
          for index = (+ (* row columns) column)
          do (setf (aref locations index) 1))))

(defun navigate (memory)
  (let* ((rows (memory-rows memory))
         (columns (memory-columns memory))
         (locations (memory-locations memory))
         (q (make-queue 0))
         (distance-to (make-hash-table))
         (end (+ (* (- rows 1) columns) (- columns 1))))
    (setf (gethash 0 distance-to) 0)
    (loop while (non-empty q)
          for current = (poll q)
          for current-distance = (gethash current distance-to)
          for row = (floor current columns)
          for column = (mod current columns)
          when (= current end)
            do (return (gethash current distance-to))
          do (when (> row 0)
               (let* ((up (- current columns))
                      (up-entry (aref locations up)))
                 (when (and (= up-entry 0) (not (gethash up distance-to)))
                   (setf (gethash up distance-to) (+ current-distance 1))
                   (enqueue up q))))
             (when (< row (- rows 1))
               (let* ((down (+ current columns))
                      (down-entry (aref locations down)))
                 (when (and (= down-entry 0) (not (gethash down distance-to)))
                   (setf (gethash down distance-to) (+ current-distance 1))
                   (enqueue down q))))
             (when (> column 0)
               (let* ((left (- current 1))
                      (left-entry (aref locations left)))
                 (when (and (= left-entry 0) (not (gethash left distance-to)))
                   (setf (gethash left distance-to) (+ current-distance 1))
                   (enqueue left q))))
             (when (< column (- columns 1))
               (let* ((right (+ current 1))
                      (right-entry (aref locations right)))
                 (when (and (= right-entry 0) (not (gethash right distance-to)))
                   (setf (gethash right distance-to) (+ current-distance 1))
                   (enqueue right q)))))))

(defun navigate-to-check-if-reachable (memory seen iteration)
  (let* ((rows (memory-rows memory))
         (columns (memory-columns memory))
         (locations (memory-locations memory))
         (stack (list 0))
         (end (the fixnum (+ (the fixnum (* (- rows 1) columns)) (- columns 1)))))
    (declare (optimize (speed 3)) (fixnum rows columns end) ((simple-array bit) locations)
             ((simple-array fixnum) seen))    
    (setf (aref seen 0) iteration)
    (loop while stack
          for current fixnum = (pop stack)
          for row fixnum = (floor current columns)
          for column fixnum = (mod current columns)
          when (= current end)
            do (return t)
          do (when (> row 0)
               (let* ((up (- current columns))
                      (up-entry (aref locations up)))
                 (when (and (= up-entry 0) (/= (aref seen up) iteration))
                   (setf (aref seen up) iteration)
                   (push up stack))))
             (when (< row (- rows 1))
               (let* ((down (+ current columns))
                      (down-entry (aref locations down)))
                 (when (and (= down-entry 0) (/= (aref seen down) iteration))
                   (setf (aref seen down) iteration)
                   (push down stack))))
             (when (> column 0)
               (let* ((left (- current 1))
                      (left-entry (aref locations left)))
                 (when (and (= left-entry 0) (/= (aref seen left) iteration))
                   (setf (aref seen left) iteration)
                   (push left stack))))
             (when (< column (- columns 1))
               (let* ((right (+ current 1))
                      (right-entry (aref locations right)))
                 (when (and (= right-entry 0) (/= (aref seen right) iteration))
                   (setf (aref seen right) iteration)
                   (push right stack)))))))

(defun part1 ()
  (let ((memory (make-memory))
        (byte-locations (read-input "day18input")))
    (let-bytes-fall byte-locations memory 1024)
    (navigate memory)))

(defun part2 ()
  (let* ((memory (make-memory))
         (byte-locations (read-input "day18input"))
         (rows (memory-rows memory))
         (columns (memory-columns memory))
         (locations (memory-locations memory))
         (seen (make-array (* rows columns) :element-type 'fixnum)))
    (let-bytes-fall byte-locations memory 1024)
    (loop for (row column) in (subseq byte-locations 1024)
          for index = (+ (* row columns) column)
          for iteration from 1
          do (setf (aref locations index) 1)
          when (not (navigate-to-check-if-reachable memory seen iteration))
            do (return (cons row column)))))
