(defpackage :day16
  (:use 
   :cl 
   :iterate 
   :alexandria 
   :queue
   :fixnum-pq
   :anaphora 
   :metabang-bind)
  (:export 
   :calibration-value
   :total-calibration-value
   :digits-in-line
   :all-calibration-values))

(in-package :day16)

(defstruct maze (rows 0 :type fixnum) (columns 0 :type fixnum) (locations "" :type string))

(defun read-input (file)
  (let ((lines (with-open-file (f file)
                 (loop for line = (read-line f nil nil)
                       while line collect line))))
    (make-maze :rows (length lines) :columns (length (car lines)) 
               :locations (apply #'concatenate 'string lines))))

(defun find-start-and-end (maze)
  (loop with start = nil
        with end = nil
        for location across (maze-locations maze)
        for index from 0
        when (char= location #\S)
          do (setf start index)
        when (char= location #\E)
          do (setf end index)
        when (and start end)
          do (return (cons start end))))

(declaim (inline turn-cost))
(defun turn-cost (current-direction required-direction)
  (case current-direction
    (E (case required-direction 
         (E 0)
         (W 2000)
         (S 1000)
         (N 1000)))
    (W (case required-direction
         (E 2000)
         (W 0)
         (S 1000)
         (N 1000)))
    (S (case required-direction
         (E 1000)
         (W 1000)
         (S 0)
         (N 2000)))
    (N (case required-direction
         (E 1000)
         (W 1000)
         (S 2000)
         (N 0)))))

(defun find-best-path (maze)
  (let* ((locations (maze-locations maze))
         (columns (maze-columns maze))
         (start-and-end (find-start-and-end maze))
         (start (car start-and-end))
         (end (cdr start-and-end))
         (pq (make-pq (length locations) (pack 0 start 'E nil)))
         (seen (make-hash-table)))
    (loop while (pq-nonempty pq)
          for element = (pop-pq pq)
          for cost = (get-cost element)
          for current = (get-index element)
          for direction = (get-direction element)
          for right = (+ current 1)
          for right-char = (aref locations right)
          for left = (- current 1)
          for left-char = (aref locations left)
          for down = (+ current columns)
          for down-char = (aref locations down)
          for up = (- current columns)
          for up-char = (aref locations up)
          when (= current end)
            do (return cost)
          do (when (and (or (char= right-char #\.) (char= right-char #\E))
                        (not (gethash right seen)))
               (let ((right-cost (+ cost (turn-cost direction 'E) 1)))
                 (insert-pq (pack right-cost right 'E nil) pq)
                 (setf (gethash right seen) t)))
             (when (and (or (char= left-char #\.) (char= left-char #\E))
                        (not (gethash left seen)))
               (let ((left-cost (+ cost (turn-cost direction 'W) 1)))
                 (insert-pq (pack left-cost left 'W nil) pq)
                 (setf (gethash left seen) t)))
             (when (and (or (char= down-char #\.) (char= down-char #\E))
                        (not (gethash down seen)))
               (let ((down-cost (+ cost (turn-cost direction 'S) 1)))
                 (insert-pq (pack down-cost down 'S nil) pq)
                 (setf (gethash down seen) t)))
             (when (and (or (char= up-char #\.) (char= up-char #\E))
                        (not (gethash up seen)))
               (let ((up-cost (+ cost (turn-cost direction 'N) 1)))
                 (insert-pq (pack up-cost up 'N nil) pq)
                 (setf (gethash up seen) t))))))

(defun part1 ()
  (let ((maze (read-input "day16input")))
    (find-best-path maze)))

(declaim (inline manhattan-distance))
(defun manhattan-distance (one-row one-column other-row other-column)
  (+ (abs (- one-row other-row)) (abs (- one-column other-column))))

(declaim (inline turning-penalty))
(defun turning-penalty (direction one-row one-column other-row other-column)
  (case direction
    (E (if (/= one-row other-row) 1000 0))
    (W (if (< one-column other-column) 2000 0))
    (S (if (< one-row other-row) 2000 0))
    (N (if (/= one-column other-column) 1000 0))))

(declaim (inline penalty))
(defun penalty (one other columns direction)
  (let ((one-row (floor one columns))
        (one-column (mod one columns))
        (other-row (floor other columns))
        (other-column (mod other columns)))
    (+ (manhattan-distance one-row one-column other-row other-column)
       (turning-penalty direction one-row one-column other-row other-column))))

(defun find-path-to (current path-history)
  (loop with path = nil
        for next = current then (gethash next path-history)
        while next
        when (numberp next)
        do (push (ash next -2) path)
        finally (return path)))

(declaim (inline direction-number))
(defun direction-number (direction)
  (case direction
    (W 0)
    (E 1)
    (S 2)
    (N 3)))

(declaim (inline cache-key))
(defun cache-key (current direction)
  (+ (ash current 2) (direction-number direction)))

(declaim (inline pack))
(defun pack (cost index direction from-junction)
  (+ (if from-junction 1 0)
     (ash (direction-number direction) 1) 
     (ash index 3)
     (ash cost 19)))

(declaim (inline get-from-junction))
(defun get-from-junction (packed)
  (= (logand packed 1) 1))

(declaim (inline get-direction))
(defun get-direction (packed)
  (case (logand (ash packed -1) 3)
    (0 'W)
    (1 'E)
    (2 'S)
    (3 'N)))

(declaim (inline get-index))
(defun get-index (packed)
  (logand (ash packed -3) 65535))

(declaim (inline get-cost))
(defun get-cost (packed)
  (ash packed (- 19)))

(defun square-is-eligible (start starting-distance starting-direction maze max-allowed)
  (let* ((locations (maze-locations maze))
         (columns (maze-columns maze))
         (start-and-end (find-start-and-end maze))
         (end (cdr start-and-end))
         (pq (make-pq (length locations) (pack starting-distance start starting-direction nil)))
         (seen (make-hash-table)))
    (declare (optimize (speed 3)) ((simple-array character) locations) 
             (fixnum end max-allowed columns))
    (setf (gethash (cache-key start starting-direction) seen) t)
    (loop while (pq-nonempty pq)
          for element fixnum = (pop-pq pq)
          for cost fixnum = (get-cost element)
          for current fixnum = (get-index element)
          for direction = (get-direction element)
          for right fixnum = (+ current 1)
          for right-char = (aref locations right)
          for left fixnum = (- current 1)
          for left-char = (aref locations left)
          for down = (+ current columns)
          for down-char = (aref locations down)
          for up = (- current columns)
          for up-char = (aref locations up)
          when (= current end)
            do (return (find-path-to (cache-key current direction) seen))
          do (when (and (or (char= right-char #\.) (char= right-char #\E))
                        (not (gethash (cache-key right 'E) seen))
                        (not (eq direction 'W)))
               (let ((right-cost (+ cost (turn-cost direction 'E) 1)))
                 (setf (gethash (cache-key right 'E) seen) (cache-key current direction))
                 (when (<= (the fixnum (+ right-cost (the fixnum (penalty right end columns 'E)))) max-allowed)
                   (insert-pq (pack right-cost right 'E nil) pq))))
             (when (and (or (char= left-char #\.) (char= left-char #\E))
                        (not (gethash (cache-key left 'W) seen))
                        (not (eq direction 'E)))
               (let ((left-cost (+ cost (turn-cost direction 'W) 1)))
                 (setf (gethash (cache-key left 'W) seen) (cache-key current direction))
                 (when (<= (the fixnum (+ left-cost (the fixnum (penalty left end columns 'W)))) max-allowed)
                   (insert-pq (pack left-cost left 'W nil) pq))))
             (when (and (or (char= down-char #\.) (char= down-char #\E))
                        (not (gethash (cache-key down 'S) seen))
                        (not (eq direction 'N)))
               (let ((down-cost (+ cost (turn-cost direction 'S) 1)))
                 (setf (gethash (cache-key down 'S) seen) (cache-key current direction))
                 (when (<= (the fixnum (+ down-cost (the fixnum (penalty down end columns 'S)))) max-allowed)
                   (insert-pq (pack down-cost down 'S nil) pq))))
             (when (and (or (char= up-char #\.) (char= up-char #\E))
                        (not (gethash (cache-key up 'N) seen))
                        (not (eq direction 'S)))
               (let ((up-cost (+ cost (turn-cost direction 'N) 1)))
                 (setf (gethash (cache-key up 'N) seen) (cache-key current direction))
                 (when (<= (the fixnum (+ up-cost (the fixnum (penalty up end columns 'N)))) max-allowed)
                   (insert-pq (pack up-cost up 'N nil) pq)))))))

(declaim (inline is-junction))
(defun is-junction (up down left right)
  (> (+ (or (and (char= up #\.) 1) 0)
        (or (and (char= down #\.) 1) 0)
        (or (and (char= left #\.) 1) 0)
        (or (and (char= right #\.) 1) 0))
     2))

(defun find-eligible-squares (maze max-allowed)
  (let* ((locations (maze-locations maze))
         (columns (maze-columns maze))
         (start-and-end (find-start-and-end maze))
         (start (car start-and-end))
         (end (cdr start-and-end))
         (pq (make-pq (length locations) (pack 0 start 'E nil)))
         (seen (make-hash-table))
         (eligible-squares (make-hash-table)))
    (loop while (pq-nonempty pq)
          for element = (pop-pq pq)
          for cost = (get-cost element)
          for current = (get-index element)
          for direction = (get-direction element)
          for from-junction = (get-from-junction element)
          for right = (+ current 1)
          for right-char = (aref locations right)
          for left = (- current 1)
          for left-char = (aref locations left)
          for down = (+ current columns)
          for down-char = (aref locations down)
          for up = (- current columns)
          for up-char = (aref locations up)
          for is-junction = (is-junction up-char down-char left-char right-char)
          when (and (or (= current start) from-junction) (not (gethash current eligible-squares)))
            do (let ((new-eligible-squares 
                       (square-is-eligible current cost direction maze max-allowed)))
                 (loop for eligible in new-eligible-squares
                       do (setf (gethash eligible eligible-squares) t)))
          do (when (and (or (char= right-char #\.) (char= right-char #\E))
                        (not (gethash (cache-key right 'E) seen))
                        (not (eq direction 'W)))
               (let ((right-cost (+ cost (turn-cost direction 'E) 1)))
                 (setf (gethash (cache-key right 'E) seen) t)
                 (when (< (+ right-cost (penalty right end columns 'E)) max-allowed)
                   (insert-pq (pack right-cost right 'E is-junction) pq))))
             (when (and (or (char= left-char #\.) (char= left-char #\E))
                        (not (gethash (cache-key left 'W) seen))
                        (not (eq direction 'E)))
               (let ((left-cost (+ cost (turn-cost direction 'W) 1)))
                 (setf (gethash (cache-key left 'W) seen) t)
                 (when (< (+ left-cost (penalty left end columns 'W)) max-allowed)
                   (insert-pq (pack left-cost left 'W is-junction) pq))))
             (when (and (or (char= down-char #\.) (char= down-char #\E))
                        (not (gethash (cache-key down 'S) seen))
                        (not (eq direction 'N)))
               (let ((down-cost (+ cost (turn-cost direction 'S) 1)))
                 (setf (gethash (cache-key down 'S) seen) t)
                 (when (< (+ down-cost (penalty down end columns 'S)) max-allowed)
                   (insert-pq (pack down-cost down 'S is-junction) pq))))
             (when (and (or (char= up-char #\.) (char= up-char #\E))
                        (not (gethash (cache-key up 'N) seen))
                        (not (eq direction 'S)))
               (let ((up-cost (+ cost (turn-cost direction 'N) 1)))
                 (setf (gethash (cache-key up 'N) seen) t)
                 (when (< (+ up-cost (penalty up end columns 'N)) max-allowed)
                   (insert-pq (pack up-cost up 'N is-junction) pq)))))
    eligible-squares))

(defun part2 ()
  (let* ((maze (read-input "day16input"))
         (best-cost (find-best-path maze)))
    (find-eligible-squares maze best-cost)))
